import {
  Fe,
  Gh,
  Gr,
  He,
  I0,
  J,
  KC,
  Le,
  M8,
  On,
  Qt,
  R,
  S,
  Ts,
  Ut,
  We,
  Ye,
  Yt,
  an,
  ct,
  e3,
  f1,
  ge,
  gl,
  iv,
  jt,
  ke,
  me,
  n3,
  q,
  qO,
  r8,
  rh,
  s8,
  we,
  x0,
  xh
} from "./chunk-EQXVLZUD.mjs";
import {
  __name
} from "./chunk-FRNSN3NF.mjs";

// ../../node_modules/.pnpm/@zenuml+core@3.17.2_ts-node@10.9.2_typescript@5.3.3/node_modules/@zenuml/core/dist/StylePanel.2c488616.js
var ze = ["top", "right", "bottom", "left"];
var Re = ["start", "end"];
var Pe = /* @__PURE__ */ ze.reduce((e, t) => e.concat(t, t + "-" + Re[0], t + "-" + Re[1]), []);
var J2 = Math.min;
var Y = Math.max;
var le = Math.round;
var se = Math.floor;
var X = /* @__PURE__ */ __name((e) => ({
  x: e,
  y: e
}), "X");
var At = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var St = {
  start: "end",
  end: "start"
};
function ye(e, t, n) {
  return Y(e, J2(t, n));
}
__name(ye, "ye");
function K(e, t) {
  return typeof e == "function" ? e(t) : e;
}
__name(K, "K");
function V(e) {
  return e.split("-")[0];
}
__name(V, "V");
function M(e) {
  return e.split("-")[1];
}
__name(M, "M");
function He2(e) {
  return e === "x" ? "y" : "x";
}
__name(He2, "He");
function xe(e) {
  return e === "y" ? "height" : "width";
}
__name(xe, "xe");
function fe(e) {
  return ["top", "bottom"].includes(V(e)) ? "y" : "x";
}
__name(fe, "fe");
function be(e) {
  return He2(fe(e));
}
__name(be, "be");
function Ve(e, t, n) {
  n === void 0 && (n = false);
  const i = M(e), o = be(e), r = xe(o);
  let s = o === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (s = ce(s)), [s, ce(s)];
}
__name(Ve, "Ve");
function Tt(e) {
  const t = ce(e);
  return [ae(e), t, ae(t)];
}
__name(Tt, "Tt");
function ae(e) {
  return e.replace(/start|end/g, (t) => St[t]);
}
__name(ae, "ae");
function Rt(e, t, n) {
  const i = ["left", "right"], o = ["right", "left"], r = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : i : t ? i : o;
    case "left":
    case "right":
      return t ? r : s;
    default:
      return [];
  }
}
__name(Rt, "Rt");
function Pt(e, t, n, i) {
  const o = M(e);
  let r = Rt(V(e), n === "start", i);
  return o && (r = r.map((s) => s + "-" + o), t && (r = r.concat(r.map(ae)))), r;
}
__name(Pt, "Pt");
function ce(e) {
  return e.replace(/left|right|bottom|top/g, (t) => At[t]);
}
__name(ce, "ce");
function Ft(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
__name(Ft, "Ft");
function We2(e) {
  return typeof e != "number" ? Ft(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
__name(We2, "We");
function ue(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
__name(ue, "ue");
function Fe2(e, t, n) {
  let {
    reference: i,
    floating: o
  } = e;
  const r = fe(t), s = be(t), l = xe(s), c = V(t), u = r === "y", m = i.x + i.width / 2 - o.width / 2, d = i.y + i.height / 2 - o.height / 2, p = i[l] / 2 - o[l] / 2;
  let f;
  switch (c) {
    case "top":
      f = {
        x: m,
        y: i.y - o.height
      };
      break;
    case "bottom":
      f = {
        x: m,
        y: i.y + i.height
      };
      break;
    case "right":
      f = {
        x: i.x + i.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: i.x - o.width,
        y: d
      };
      break;
    default:
      f = {
        x: i.x,
        y: i.y
      };
  }
  switch (M(t)) {
    case "start":
      f[s] -= p * (n && u ? -1 : 1);
      break;
    case "end":
      f[s] += p * (n && u ? -1 : 1);
      break;
  }
  return f;
}
__name(Fe2, "Fe");
var Lt = /* @__PURE__ */ __name(async (e, t, n) => {
  const {
    placement: i = "bottom",
    strategy: o = "absolute",
    middleware: r = [],
    platform: s
  } = n, l = r.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let u = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: m,
    y: d
  } = Fe2(u, i, c), p = i, f = {}, a = 0;
  for (let h = 0; h < l.length; h++) {
    const {
      name: v,
      fn: g
    } = l[h], {
      x,
      y: b,
      data: C,
      reset: w
    } = await g({
      x: m,
      y: d,
      initialPlacement: i,
      placement: p,
      strategy: o,
      middlewareData: f,
      rects: u,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (m = x != null ? x : m, d = b != null ? b : d, f = {
      ...f,
      [v]: {
        ...f[v],
        ...C
      }
    }, w && a <= 50) {
      a++, typeof w == "object" && (w.placement && (p = w.placement), w.rects && (u = w.rects === true ? await s.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : w.rects), {
        x: m,
        y: d
      } = Fe2(u, p, c)), h = -1;
      continue;
    }
  }
  return {
    x: m,
    y: d,
    placement: p,
    strategy: o,
    middlewareData: f
  };
}, "Lt");
async function ne(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: i,
    y: o,
    platform: r,
    rects: s,
    elements: l,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: m = "viewport",
    elementContext: d = "floating",
    altBoundary: p = false,
    padding: f = 0
  } = K(t, e), a = We2(f), v = l[p ? d === "floating" ? "reference" : "floating" : d], g = ue(await r.getClippingRect({
    element: (n = await (r.isElement == null ? void 0 : r.isElement(v))) == null || n ? v : v.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(l.floating)),
    boundary: u,
    rootBoundary: m,
    strategy: c
  })), x = d === "floating" ? {
    ...s.floating,
    x: i,
    y: o
  } : s.reference, b = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(l.floating)), C = await (r.isElement == null ? void 0 : r.isElement(b)) ? await (r.getScale == null ? void 0 : r.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = ue(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: x,
    offsetParent: b,
    strategy: c
  }) : x);
  return {
    top: (g.top - w.top + a.top) / C.y,
    bottom: (w.bottom - g.bottom + a.bottom) / C.y,
    left: (g.left - w.left + a.left) / C.x,
    right: (w.right - g.right + a.right) / C.x
  };
}
__name(ne, "ne");
var Bt = /* @__PURE__ */ __name((e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: i,
      placement: o,
      rects: r,
      platform: s,
      elements: l,
      middlewareData: c
    } = t, {
      element: u,
      padding: m = 0
    } = K(e, t) || {};
    if (u == null)
      return {};
    const d = We2(m), p = {
      x: n,
      y: i
    }, f = be(o), a = xe(f), h = await s.getDimensions(u), v = f === "y", g = v ? "top" : "left", x = v ? "bottom" : "right", b = v ? "clientHeight" : "clientWidth", C = r.reference[a] + r.reference[f] - p[f] - r.floating[a], w = p[f] - r.reference[f], O = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(u));
    let E = O ? O[b] : 0;
    (!E || !await (s.isElement == null ? void 0 : s.isElement(O))) && (E = l.floating[b] || r.floating[a]);
    const A = C / 2 - w / 2, R2 = E / 2 - h[a] / 2 - 1, T = J2(d[g], R2), S2 = J2(d[x], R2), P = T, _ = E - h[a] - S2, B = E / 2 - h[a] / 2 + A, N = ye(P, B, _), $ = !c.arrow && M(o) != null && B != N && r.reference[a] / 2 - (B < P ? T : S2) - h[a] / 2 < 0, z = $ ? B < P ? B - P : B - _ : 0;
    return {
      [f]: p[f] + z,
      data: {
        [f]: N,
        centerOffset: B - N - z,
        ...$ && {
          alignmentOffset: z
        }
      },
      reset: $
    };
  }
}), "Bt");
function kt(e, t, n) {
  return (e ? [...n.filter((o) => M(o) === e), ...n.filter((o) => M(o) !== e)] : n.filter((o) => V(o) === o)).filter((o) => e ? M(o) === e || (t ? ae(o) !== o : false) : true);
}
__name(kt, "kt");
var Dt = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "autoPlacement",
    options: e,
    async fn(t) {
      var n, i, o;
      const {
        rects: r,
        middlewareData: s,
        placement: l,
        platform: c,
        elements: u
      } = t, {
        crossAxis: m = false,
        alignment: d,
        allowedPlacements: p = Pe,
        autoAlignment: f = true,
        ...a
      } = K(e, t), h = d !== void 0 || p === Pe ? kt(d || null, f, p) : p, v = await ne(t, a), g = ((n = s.autoPlacement) == null ? void 0 : n.index) || 0, x = h[g];
      if (x == null)
        return {};
      const b = Ve(x, r, await (c.isRTL == null ? void 0 : c.isRTL(u.floating)));
      if (l !== x)
        return {
          reset: {
            placement: h[0]
          }
        };
      const C = [v[V(x)], v[b[0]], v[b[1]]], w = [...((i = s.autoPlacement) == null ? void 0 : i.overflows) || [], {
        placement: x,
        overflows: C
      }], O = h[g + 1];
      if (O)
        return {
          data: {
            index: g + 1,
            overflows: w
          },
          reset: {
            placement: O
          }
        };
      const E = w.map((T) => {
        const S2 = M(T.placement);
        return [T.placement, S2 && m ? T.overflows.slice(0, 2).reduce((P, _) => P + _, 0) : T.overflows[0], T.overflows];
      }).sort((T, S2) => T[1] - S2[1]), R2 = ((o = E.filter((T) => T[2].slice(
        0,
        M(T[0]) ? 2 : 3
      ).every((S2) => S2 <= 0))[0]) == null ? void 0 : o[0]) || E[0][0];
      return R2 !== l ? {
        data: {
          index: g + 1,
          overflows: w
        },
        reset: {
          placement: R2
        }
      } : {};
    }
  };
}, "Dt");
var Nt = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, i;
      const {
        placement: o,
        middlewareData: r,
        rects: s,
        initialPlacement: l,
        platform: c,
        elements: u
      } = t, {
        mainAxis: m = true,
        crossAxis: d = true,
        fallbackPlacements: p,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: a = "none",
        flipAlignment: h = true,
        ...v
      } = K(e, t);
      if ((n = r.arrow) != null && n.alignmentOffset)
        return {};
      const g = V(o), x = V(l) === l, b = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), C = p || (x || !h ? [ce(l)] : Tt(l));
      !p && a !== "none" && C.push(...Pt(l, h, a, b));
      const w = [l, ...C], O = await ne(t, v), E = [];
      let A = ((i = r.flip) == null ? void 0 : i.overflows) || [];
      if (m && E.push(O[g]), d) {
        const P = Ve(o, s, b);
        E.push(O[P[0]], O[P[1]]);
      }
      if (A = [...A, {
        placement: o,
        overflows: E
      }], !E.every((P) => P <= 0)) {
        var R2, T;
        const P = (((R2 = r.flip) == null ? void 0 : R2.index) || 0) + 1, _ = w[P];
        if (_)
          return {
            data: {
              index: P,
              overflows: A
            },
            reset: {
              placement: _
            }
          };
        let B = (T = A.filter((N) => N.overflows[0] <= 0).sort((N, $) => N.overflows[1] - $.overflows[1])[0]) == null ? void 0 : T.placement;
        if (!B)
          switch (f) {
            case "bestFit": {
              var S2;
              const N = (S2 = A.map(($) => [$.placement, $.overflows.filter((z) => z > 0).reduce((z, tt) => z + tt, 0)]).sort(($, z) => $[1] - z[1])[0]) == null ? void 0 : S2[0];
              N && (B = N);
              break;
            }
            case "initialPlacement":
              B = l;
              break;
          }
        if (o !== B)
          return {
            reset: {
              placement: B
            }
          };
      }
      return {};
    }
  };
}, "Nt");
function Le2(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
__name(Le2, "Le");
function Be(e) {
  return ze.some((t) => e[t] >= 0);
}
__name(Be, "Be");
var $t = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: i = "referenceHidden",
        ...o
      } = K(e, t);
      switch (i) {
        case "referenceHidden": {
          const r = await ne(t, {
            ...o,
            elementContext: "reference"
          }), s = Le2(r, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Be(s)
            }
          };
        }
        case "escaped": {
          const r = await ne(t, {
            ...o,
            altBoundary: true
          }), s = Le2(r, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Be(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, "$t");
async function jt2(e, t) {
  const {
    placement: n,
    platform: i,
    elements: o
  } = e, r = await (i.isRTL == null ? void 0 : i.isRTL(o.floating)), s = V(n), l = M(n), c = fe(n) === "y", u = ["left", "top"].includes(s) ? -1 : 1, m = r && c ? -1 : 1, d = K(t, e);
  let {
    mainAxis: p,
    crossAxis: f,
    alignmentAxis: a
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return l && typeof a == "number" && (f = l === "end" ? a * -1 : a), c ? {
    x: f * m,
    y: p * u
  } : {
    x: p * u,
    y: f * m
  };
}
__name(jt2, "jt");
var Mt = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: i
      } = t, o = await jt2(t, e);
      return {
        x: n + o.x,
        y: i + o.y,
        data: o
      };
    }
  };
}, "Mt");
var It = /* @__PURE__ */ __name(function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: i,
        placement: o
      } = t, {
        mainAxis: r = true,
        crossAxis: s = false,
        limiter: l = {
          fn: (v) => {
            let {
              x: g,
              y: x
            } = v;
            return {
              x: g,
              y: x
            };
          }
        },
        ...c
      } = K(e, t), u = {
        x: n,
        y: i
      }, m = await ne(t, c), d = fe(V(o)), p = He2(d);
      let f = u[p], a = u[d];
      if (r) {
        const v = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", x = f + m[v], b = f - m[g];
        f = ye(x, f, b);
      }
      if (s) {
        const v = d === "y" ? "top" : "left", g = d === "y" ? "bottom" : "right", x = a + m[v], b = a - m[g];
        a = ye(x, a, b);
      }
      const h = l.fn({
        ...t,
        [p]: f,
        [d]: a
      });
      return {
        ...h,
        data: {
          x: h.x - n,
          y: h.y - i
        }
      };
    }
  };
}, "It");
function q2(e) {
  return Ue(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
__name(q2, "q");
function k(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
__name(k, "k");
function U(e) {
  var t;
  return (t = (Ue(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
__name(U, "U");
function Ue(e) {
  return e instanceof Node || e instanceof k(e).Node;
}
__name(Ue, "Ue");
function W(e) {
  return e instanceof Element || e instanceof k(e).Element;
}
__name(W, "W");
function I(e) {
  return e instanceof HTMLElement || e instanceof k(e).HTMLElement;
}
__name(I, "I");
function ke2(e) {
  return typeof ShadowRoot > "u" ? false : e instanceof ShadowRoot || e instanceof k(e).ShadowRoot;
}
__name(ke2, "ke");
function re(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: i,
    display: o
  } = D(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + i + n) && !["inline", "contents"].includes(o);
}
__name(re, "re");
function _t(e) {
  return ["table", "td", "th"].includes(q2(e));
}
__name(_t, "_t");
function Ce(e) {
  const t = Oe(), n = D(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : false) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !t && (n.filter ? n.filter !== "none" : false) || ["transform", "perspective", "filter"].some((i) => (n.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (n.contain || "").includes(i));
}
__name(Ce, "Ce");
function zt(e) {
  let t = ee(e);
  for (; I(t) && !de(t); ) {
    if (Ce(t))
      return t;
    t = ee(t);
  }
  return null;
}
__name(zt, "zt");
function Oe() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
__name(Oe, "Oe");
function de(e) {
  return ["html", "body", "#document"].includes(q2(e));
}
__name(de, "de");
function D(e) {
  return k(e).getComputedStyle(e);
}
__name(D, "D");
function me2(e) {
  return W(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
__name(me2, "me");
function ee(e) {
  if (q2(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || ke2(e) && e.host || U(e);
  return ke2(t) ? t.host : t;
}
__name(ee, "ee");
function Xe(e) {
  const t = ee(e);
  return de(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : I(t) && re(t) ? t : Xe(t);
}
__name(Xe, "Xe");
function oe(e, t, n) {
  var i;
  t === void 0 && (t = []), n === void 0 && (n = true);
  const o = Xe(e), r = o === ((i = e.ownerDocument) == null ? void 0 : i.body), s = k(o);
  return r ? t.concat(s, s.visualViewport || [], re(o) ? o : [], s.frameElement && n ? oe(s.frameElement) : []) : t.concat(o, oe(o, [], n));
}
__name(oe, "oe");
function qe(e) {
  const t = D(e);
  let n = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  const o = I(e), r = o ? e.offsetWidth : n, s = o ? e.offsetHeight : i, l = le(n) !== r || le(i) !== s;
  return l && (n = r, i = s), {
    width: n,
    height: i,
    $: l
  };
}
__name(qe, "qe");
function Ee(e) {
  return W(e) ? e : e.contextElement;
}
__name(Ee, "Ee");
function Z(e) {
  const t = Ee(e);
  if (!I(t))
    return X(1);
  const n = t.getBoundingClientRect(), {
    width: i,
    height: o,
    $: r
  } = qe(t);
  let s = (r ? le(n.width) : n.width) / i, l = (r ? le(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!l || !Number.isFinite(l)) && (l = 1), {
    x: s,
    y: l
  };
}
__name(Z, "Z");
var Ht = /* @__PURE__ */ X(0);
function Ye2(e) {
  const t = k(e);
  return !Oe() || !t.visualViewport ? Ht : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
__name(Ye2, "Ye");
function Vt(e, t, n) {
  return t === void 0 && (t = false), !n || t && n !== k(e) ? false : t;
}
__name(Vt, "Vt");
function G(e, t, n, i) {
  t === void 0 && (t = false), n === void 0 && (n = false);
  const o = e.getBoundingClientRect(), r = Ee(e);
  let s = X(1);
  t && (i ? W(i) && (s = Z(i)) : s = Z(e));
  const l = Vt(r, n, i) ? Ye2(r) : X(0);
  let c = (o.left + l.x) / s.x, u = (o.top + l.y) / s.y, m = o.width / s.x, d = o.height / s.y;
  if (r) {
    const p = k(r), f = i && W(i) ? k(i) : i;
    let a = p.frameElement;
    for (; a && i && f !== p; ) {
      const h = Z(a), v = a.getBoundingClientRect(), g = D(a), x = v.left + (a.clientLeft + parseFloat(g.paddingLeft)) * h.x, b = v.top + (a.clientTop + parseFloat(g.paddingTop)) * h.y;
      c *= h.x, u *= h.y, m *= h.x, d *= h.y, c += x, u += b, a = k(a).frameElement;
    }
  }
  return ue({
    width: m,
    height: d,
    x: c,
    y: u
  });
}
__name(G, "G");
function Wt(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: i
  } = e;
  const o = I(n), r = U(n);
  if (n === r)
    return t;
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = X(1);
  const c = X(0);
  if ((o || !o && i !== "fixed") && ((q2(n) !== "body" || re(r)) && (s = me2(n)), I(n))) {
    const u = G(n);
    l = Z(n), c.x = u.x + n.clientLeft, c.y = u.y + n.clientTop;
  }
  return {
    width: t.width * l.x,
    height: t.height * l.y,
    x: t.x * l.x - s.scrollLeft * l.x + c.x,
    y: t.y * l.y - s.scrollTop * l.y + c.y
  };
}
__name(Wt, "Wt");
function Ut2(e) {
  return Array.from(e.getClientRects());
}
__name(Ut2, "Ut");
function Ge(e) {
  return G(U(e)).left + me2(e).scrollLeft;
}
__name(Ge, "Ge");
function Xt(e) {
  const t = U(e), n = me2(e), i = e.ownerDocument.body, o = Y(t.scrollWidth, t.clientWidth, i.scrollWidth, i.clientWidth), r = Y(t.scrollHeight, t.clientHeight, i.scrollHeight, i.clientHeight);
  let s = -n.scrollLeft + Ge(e);
  const l = -n.scrollTop;
  return D(i).direction === "rtl" && (s += Y(t.clientWidth, i.clientWidth) - o), {
    width: o,
    height: r,
    x: s,
    y: l
  };
}
__name(Xt, "Xt");
function qt(e, t) {
  const n = k(e), i = U(e), o = n.visualViewport;
  let r = i.clientWidth, s = i.clientHeight, l = 0, c = 0;
  if (o) {
    r = o.width, s = o.height;
    const u = Oe();
    (!u || u && t === "fixed") && (l = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: l,
    y: c
  };
}
__name(qt, "qt");
function Yt2(e, t) {
  const n = G(e, true, t === "fixed"), i = n.top + e.clientTop, o = n.left + e.clientLeft, r = I(e) ? Z(e) : X(1), s = e.clientWidth * r.x, l = e.clientHeight * r.y, c = o * r.x, u = i * r.y;
  return {
    width: s,
    height: l,
    x: c,
    y: u
  };
}
__name(Yt2, "Yt");
function De(e, t, n) {
  let i;
  if (t === "viewport")
    i = qt(e, n);
  else if (t === "document")
    i = Xt(U(e));
  else if (W(t))
    i = Yt2(t, n);
  else {
    const o = Ye2(e);
    i = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return ue(i);
}
__name(De, "De");
function Ke(e, t) {
  const n = ee(e);
  return n === t || !W(n) || de(n) ? false : D(n).position === "fixed" || Ke(n, t);
}
__name(Ke, "Ke");
function Gt(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let i = oe(e, [], false).filter((l) => W(l) && q2(l) !== "body"), o = null;
  const r = D(e).position === "fixed";
  let s = r ? ee(e) : e;
  for (; W(s) && !de(s); ) {
    const l = D(s), c = Ce(s);
    !c && l.position === "fixed" && (o = null), (r ? !c && !o : !c && l.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || re(s) && !c && Ke(e, s)) ? i = i.filter((m) => m !== s) : o = l, s = ee(s);
  }
  return t.set(e, i), i;
}
__name(Gt, "Gt");
function Kt(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: i,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? Gt(t, this._c) : [].concat(n), i], l = s[0], c = s.reduce((u, m) => {
    const d = De(t, m, o);
    return u.top = Y(d.top, u.top), u.right = J2(d.right, u.right), u.bottom = J2(d.bottom, u.bottom), u.left = Y(d.left, u.left), u;
  }, De(t, l, o));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
__name(Kt, "Kt");
function Qt2(e) {
  return qe(e);
}
__name(Qt2, "Qt");
function Zt(e, t, n) {
  const i = I(t), o = U(t), r = n === "fixed", s = G(e, true, r, t);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = X(0);
  if (i || !i && !r)
    if ((q2(t) !== "body" || re(o)) && (l = me2(t)), i) {
      const u = G(t, true, r, t);
      c.x = u.x + t.clientLeft, c.y = u.y + t.clientTop;
    } else
      o && (c.x = Ge(o));
  return {
    x: s.left + l.scrollLeft - c.x,
    y: s.top + l.scrollTop - c.y,
    width: s.width,
    height: s.height
  };
}
__name(Zt, "Zt");
function Ne(e, t) {
  return !I(e) || D(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
__name(Ne, "Ne");
function Qe(e, t) {
  const n = k(e);
  if (!I(e))
    return n;
  let i = Ne(e, t);
  for (; i && _t(i) && D(i).position === "static"; )
    i = Ne(i, t);
  return i && (q2(i) === "html" || q2(i) === "body" && D(i).position === "static" && !Ce(i)) ? n : i || zt(e) || n;
}
__name(Qe, "Qe");
var Jt = /* @__PURE__ */ __name(async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: i
  } = e;
  const o = this.getOffsetParent || Qe, r = this.getDimensions;
  return {
    reference: Zt(t, await o(n), i),
    floating: {
      x: 0,
      y: 0,
      ...await r(n)
    }
  };
}, "Jt");
function en(e) {
  return D(e).direction === "rtl";
}
__name(en, "en");
var tn = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Wt,
  getDocumentElement: U,
  getClippingRect: Kt,
  getOffsetParent: Qe,
  getElementRects: Jt,
  getClientRects: Ut2,
  getDimensions: Qt2,
  getScale: Z,
  isElement: W,
  isRTL: en
};
function nn(e, t) {
  let n = null, i;
  const o = U(e);
  function r() {
    clearTimeout(i), n && n.disconnect(), n = null;
  }
  __name(r, "r");
  function s(l, c) {
    l === void 0 && (l = false), c === void 0 && (c = 1), r();
    const {
      left: u,
      top: m,
      width: d,
      height: p
    } = e.getBoundingClientRect();
    if (l || t(), !d || !p)
      return;
    const f = se(m), a = se(o.clientWidth - (u + d)), h = se(o.clientHeight - (m + p)), v = se(u), x = {
      rootMargin: -f + "px " + -a + "px " + -h + "px " + -v + "px",
      threshold: Y(0, J2(1, c)) || 1
    };
    let b = true;
    function C(w) {
      const O = w[0].intersectionRatio;
      if (O !== c) {
        if (!b)
          return s();
        O ? s(false, O) : i = setTimeout(() => {
          s(false, 1e-7);
        }, 100);
      }
      b = false;
    }
    __name(C, "C");
    try {
      n = new IntersectionObserver(C, {
        ...x,
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, x);
    }
    n.observe(e);
  }
  __name(s, "s");
  return s(true), r;
}
__name(nn, "nn");
function on(e, t, n, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: o = true,
    ancestorResize: r = true,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: l = typeof IntersectionObserver == "function",
    animationFrame: c = false
  } = i, u = Ee(e), m = o || r ? [...u ? oe(u) : [], ...oe(t)] : [];
  m.forEach((g) => {
    o && g.addEventListener("scroll", n, {
      passive: true
    }), r && g.addEventListener("resize", n);
  });
  const d = u && l ? nn(u, n) : null;
  let p = -1, f = null;
  s && (f = new ResizeObserver((g) => {
    let [x] = g;
    x && x.target === u && f && (f.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      f && f.observe(t);
    })), n();
  }), u && !c && f.observe(u), f.observe(t));
  let a, h = c ? G(e) : null;
  c && v();
  function v() {
    const g = G(e);
    h && (g.x !== h.x || g.y !== h.y || g.width !== h.width || g.height !== h.height) && n(), h = g, a = requestAnimationFrame(v);
  }
  __name(v, "v");
  return n(), () => {
    m.forEach((g) => {
      o && g.removeEventListener("scroll", n), r && g.removeEventListener("resize", n);
    }), d && d(), f && f.disconnect(), f = null, c && cancelAnimationFrame(a);
  };
}
__name(on, "on");
var rn = /* @__PURE__ */ __name((e, t, n) => {
  const i = /* @__PURE__ */ new Map(), o = {
    platform: tn,
    ...n
  }, r = {
    ...o.platform,
    _c: i
  };
  return Lt(e, t, {
    ...o,
    platform: r
  });
}, "rn");
function we2(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
__name(we2, "we");
function sn(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = we2(Le(e.element));
      return n == null ? {} : Bt({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
__name(sn, "sn");
function ln(e, t, n) {
  n === void 0 && (n = {});
  const i = n.whileElementsMounted, o = J(() => {
    var w;
    return (w = Le(n.open)) != null ? w : true;
  }), r = J(() => Le(n.middleware)), s = J(() => {
    var w;
    return (w = Le(n.placement)) != null ? w : "bottom";
  }), l = J(() => {
    var w;
    return (w = Le(n.strategy)) != null ? w : "absolute";
  }), c = J(() => we2(e.value)), u = J(() => we2(t.value)), m = ge(null), d = ge(null), p = ge(l.value), f = ge(s.value), a = e3({}), h = ge(false);
  let v;
  function g() {
    c.value == null || u.value == null || rn(c.value, u.value, {
      middleware: r.value,
      placement: s.value,
      strategy: l.value
    }).then((w) => {
      m.value = w.x, d.value = w.y, p.value = w.strategy, f.value = w.placement, a.value = w.middlewareData, h.value = true;
    });
  }
  __name(g, "g");
  function x() {
    typeof v == "function" && (v(), v = void 0);
  }
  __name(x, "x");
  function b() {
    if (x(), i === void 0) {
      g();
      return;
    }
    if (c.value != null && u.value != null) {
      v = i(c.value, u.value, g);
      return;
    }
  }
  __name(b, "b");
  function C() {
    o.value || (h.value = false);
  }
  __name(C, "C");
  return Yt([r, s, l], g, {
    flush: "sync"
  }), Yt([c, u], b, {
    flush: "sync"
  }), Yt(o, C, {
    flush: "sync"
  }), r8() && s8(x), {
    x: M8(m),
    y: M8(d),
    strategy: M8(p),
    placement: M8(f),
    middlewareData: M8(a),
    isPositioned: M8(h),
    update: g
  };
}
__name(ln, "ln");
var an2 = Object.defineProperty;
var cn = /* @__PURE__ */ __name((e, t, n) => t in e ? an2(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n, "cn");
var un = /* @__PURE__ */ __name((e, t, n) => (cn(e, typeof t != "symbol" ? t + "" : t, n), n), "un");
function ie(e) {
  var n;
  if (e == null || e.value == null)
    return null;
  const t = (n = e.value.$el) != null ? n : e.value;
  return t.$el ? ie(ge(t)) : t;
}
__name(ie, "ie");
var fn = class {
  static {
    __name(this, "fn");
  }
  constructor() {
    un(this, "current", this.detect());
  }
  set(t) {
    this.current !== t && (this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
};
var pe = new fn();
function Ze(e) {
  return e.reduce((t, n) => n.type === Fe ? t.concat(Ze(n.children)) : t.concat(n), []);
}
__name(Ze, "Ze");
function dn(e) {
  return e == null ? false : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
__name(dn, "dn");
function $e(e) {
  return e = Le(e), e && (e == null ? void 0 : e.nodeType) !== Node.COMMENT_NODE;
}
__name($e, "$e");
function mn(e) {
  if (pe.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (Object.prototype.hasOwnProperty.call(e, "value")) {
    const t = ie(e);
    if (t)
      return t.ownerDocument;
  }
  return document;
}
__name(mn, "mn");
function pn(e, t, n, i, o) {
  Yt([
    () => o.offset,
    () => o.flip,
    () => o.shift,
    () => o.autoPlacement,
    () => o.arrow,
    () => o.hide,
    () => o.middleware
  ], () => {
    const r = [];
    (typeof o.offset == "number" || typeof o.offset == "object" || typeof o.offset == "function") && r.push(Mt(o.offset)), (o.flip === true || typeof o.flip == "number" || typeof o.flip == "object") && r.push(Nt({
      padding: typeof o.flip == "number" ? o.flip : void 0,
      ...typeof o.flip == "object" ? o.flip : {}
    })), (o.shift === true || typeof o.shift == "number" || typeof o.shift == "object") && r.push(It({
      padding: typeof o.shift == "number" ? o.shift : void 0,
      ...typeof o.shift == "object" ? o.shift : {}
    })), (o.autoPlacement === true || typeof o.autoPlacement == "object") && r.push(Dt(
      typeof o.autoPlacement == "object" ? o.autoPlacement : void 0
    )), (o.arrow === true || typeof o.arrow == "number") && r.push(sn({
      element: i,
      padding: o.arrow === true ? 0 : o.arrow
    })), r.push(...typeof o.middleware == "function" ? o.middleware({
      referenceEl: t,
      floatingEl: n
    }) : o.middleware || []), (o.hide === true || typeof o.hide == "object") && r.push($t(
      typeof o.hide == "object" ? o.hide : void 0
    )), e.value = r;
  }, { immediate: true });
}
__name(pn, "pn");
function gn(e, t, n) {
  let i = /* @__PURE__ */ __name(() => {
  }, "i");
  We(() => {
    if (e && pe.isClient && typeof ResizeObserver < "u" && t.value && t.value instanceof Element) {
      const o = new ResizeObserver(([r]) => {
        n.value = r.borderBoxSize.reduce((s, { inlineSize: l }) => s + l, 0);
      });
      o.observe(t.value), i = /* @__PURE__ */ __name(() => {
        o.disconnect(), n.value = null;
      }, "i");
    }
  }), x0(() => {
    i();
  });
}
__name(gn, "gn");
var hn = /* @__PURE__ */ __name((e) => {
  switch (e) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "";
  }
}, "hn");
function vn(e, t) {
  const n = J(() => {
    if (typeof e.originClass == "function")
      return e.originClass(t.value);
    if (typeof e.originClass == "string")
      return e.originClass;
    if (e.tailwindcssOriginClass)
      return hn(t.value);
  }), i = J(
    () => e.enter || n.value ? `${e.enter || ""} ${n.value || ""}` : void 0
  ), o = J(
    () => e.leave || n.value ? `${e.leave || ""} ${n.value || ""}` : void 0
  );
  return { originClassRef: n, enterActiveClassRef: i, leaveActiveClassRef: o };
}
__name(vn, "vn");
function Je(e, t, ...n) {
  if (e in t) {
    const o = t[e];
    return typeof o == "function" ? o(...n) : o;
  }
  const i = new Error(
    `Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      t
    ).map((o) => `"${o}"`).join(", ")}.`
  );
  throw Error.captureStackTrace && Error.captureStackTrace(i, Je), i;
}
__name(Je, "Je");
var je = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(
  (e) => `${e}:not([tabindex='-1'])`
).join(",");
var et = /* @__PURE__ */ ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(et || {});
function yn(e, t = 0) {
  var n;
  return e === ((n = mn(e)) == null ? void 0 : n.body) ? false : Je(t, {
    0() {
      return e.matches(je);
    },
    1() {
      let i = e;
      for (; i !== null; ) {
        if (i.matches(je))
          return true;
        i = i.parentElement;
      }
      return false;
    }
  });
}
__name(yn, "yn");
function ve(e, t, n) {
  pe.isServer || Qt((i) => {
    document.addEventListener(e, t, n), i(() => document.removeEventListener(e, t, n));
  });
}
__name(ve, "ve");
function wn(e, t, n = J(() => true)) {
  function i(r, s) {
    if (!n.value || r.defaultPrevented)
      return;
    const l = s(r);
    if (l === null || !l.getRootNode().contains(l))
      return;
    const c = (/* @__PURE__ */ __name(function u(m) {
      return typeof m == "function" ? u(m()) : Array.isArray(m) || m instanceof Set ? m : [m];
    }, "u"))(e);
    for (const u of c) {
      if (u === null)
        continue;
      const m = u instanceof HTMLElement ? u : ie(u);
      if (m != null && m.contains(l) || r.composed && r.composedPath().includes(m))
        return;
    }
    return !yn(l, et.Loose) && l.tabIndex !== -1 && r.preventDefault(), t(r, l);
  }
  __name(i, "i");
  const o = ge(null);
  ve("mousedown", (r) => {
    var s, l;
    n.value && (o.value = ((l = (s = r.composedPath) == null ? void 0 : s.call(r)) == null ? void 0 : l[0]) || r.target);
  }, true), ve(
    "click",
    (r) => {
      o.value && (i(r, () => o.value), o.value = null);
    },
    true
  ), ve("blur", (r) => i(
    r,
    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null
  ), true);
}
__name(wn, "wn");
var xn = Symbol("ArrowContext");
var y = {
  as: {
    type: [String, Function],
    default: "template"
  },
  floatingAs: {
    type: [String, Function],
    default: "div"
  },
  show: {
    type: Boolean,
    default: null
  },
  placement: {
    type: String,
    default: "bottom-start"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offset: [Number, Function, Object],
  shift: {
    type: [Boolean, Number, Object],
    default: false
  },
  flip: {
    type: [Boolean, Number, Object],
    default: false
  },
  arrow: {
    type: [Boolean, Number],
    default: false
  },
  autoPlacement: {
    type: [Boolean, Object],
    default: false
  },
  hide: {
    type: [Boolean, Object],
    default: false
  },
  autoUpdate: {
    type: [Boolean, Object],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 9999
  },
  transitionName: String,
  transitionType: String,
  enter: String,
  enterFrom: String,
  enterTo: String,
  leave: String,
  leaveFrom: String,
  leaveTo: String,
  originClass: [String, Function],
  tailwindcssOriginClass: {
    type: Boolean,
    default: false
  },
  portal: {
    type: Boolean,
    default: false
  },
  transform: {
    type: Boolean,
    default: true
  },
  adaptiveWidth: {
    type: Boolean,
    default: false
  },
  composable: {
    type: Boolean,
    default: false
  },
  dialog: {
    type: Boolean,
    default: false
  },
  middleware: {
    type: [Array, Function],
    default: () => []
  }
};
function bn(e, t, n, i) {
  const { floatingRef: o, props: r, mounted: s, show: l, x: c, y: u, placement: m, strategy: d, referenceElWidth: p, updateFloating: f } = i, a = f1(
    { ...r, as: r.floatingAs },
    t
  ), { enterActiveClassRef: h, leaveActiveClassRef: v } = vn(a, m), g = {
    enterActiveClass: h.value,
    enterFromClass: a.enterFrom,
    enterToClass: a.enterTo,
    leaveActiveClass: v.value,
    leaveFromClass: a.leaveFrom,
    leaveToClass: a.leaveTo
  }, x = {
    name: a.transitionName,
    type: a.transitionType,
    appear: true,
    ...a.transitionName ? {} : g,
    onBeforeEnter() {
      l.value = true;
    },
    onAfterLeave() {
      l.value = false;
    }
  }, b = {
    enter: h.value,
    enterFrom: a.enterFrom,
    enterTo: a.enterTo,
    leave: v.value,
    leaveFrom: a.leaveFrom,
    leaveTo: a.leaveTo,
    onBeforeEnter: x.onBeforeEnter,
    onAfterLeave: x.onAfterLeave
  }, C = {
    style: {
      ...!a.dialog && a.transform ? {
        position: d.value,
        zIndex: a.zIndex,
        top: "0px",
        left: "0px",
        right: "auto",
        bottom: "auto",
        transform: `translate(${Math.round(c.value || 0)}px,${Math.round(u.value || 0)}px)`
      } : {
        position: d.value,
        zIndex: a.zIndex,
        top: `${u.value || 0}px`,
        left: `${c.value || 0}px`
      },
      width: a.adaptiveWidth && typeof p.value == "number" ? `${p.value}px` : void 0
    }
  };
  function w(A) {
    return a.portal ? ct(Gh, () => A) : A;
  }
  __name(w, "w");
  function O(A) {
    const R2 = f1(
      C,
      n,
      a.dialog ? {} : { ref: o }
    );
    return a.as === "template" ? A : typeof a.as == "string" ? ct(a.as, R2, A) : ct(a.as, R2, () => A);
  }
  __name(O, "O");
  function E() {
    function A() {
      var R2;
      const T = a.as === "template" ? f1(
        C,
        n,
        a.dialog ? {} : { ref: o }
      ) : null, S2 = an(e, T);
      return ((R2 = S2.props) == null ? void 0 : R2.unmount) === false ? (f(), S2) : typeof a.show != "boolean" || a.show ? S2 : me();
    }
    __name(A, "A");
    return pe.isServer ? s.value && a.show ? A() : me() : a.transitionChild ? ct(gl, {
      key: `placement-${m.value}`,
      ...a.dialog ? { ref: o } : {},
      as: "template",
      ...b
    }, A) : ct(I0, {
      ...a.dialog ? { ref: o } : {},
      ...x
    }, A);
  }
  __name(E, "E");
  return w(
    O(
      E()
    )
  );
}
__name(bn, "bn");
function Cn(e, t, n, i, o) {
  const r = ge(false), s = n3(i, "placement"), l = n3(i, "strategy"), c = e3({}), u = ge(null), m = ge(void 0), d = ge(void 0), p = J(() => ie(t)), f = J(() => ie(n)), a = J(
    () => $e(p) && $e(f)
  ), { x: h, y: v, placement: g, strategy: x, middlewareData: b, update: C } = ln(p, f, {
    placement: s,
    strategy: l,
    middleware: c,
    whileElementsMounted: () => {
    }
  }), w = ge(null);
  We(() => {
    r.value = true;
  }), Yt(e, (S2, P) => {
    S2 && !P ? o("show") : !S2 && P && o("hide");
  }, { immediate: true });
  function O() {
    a.value && (C(), o("update"));
  }
  __name(O, "O");
  Yt([s, l, c], O, { flush: "sync" }), pn(
    c,
    p,
    f,
    u,
    i
  ), Yt(b, () => {
    const S2 = b.value.arrow;
    m.value = S2 == null ? void 0 : S2.x, d.value = S2 == null ? void 0 : S2.y;
  }), gn(i.adaptiveWidth, p, w), Yt(e, async (S2, P, _) => {
    if (await Ts(), e.value && a.value && i.autoUpdate) {
      const B = on(
        p.value,
        f.value,
        O,
        typeof i.autoUpdate == "object" ? i.autoUpdate : void 0
      );
      _(B);
    }
  }, { flush: "post", immediate: true });
  const E = ge(true);
  Yt(p, () => {
    !(p.value instanceof Element) && a.value && E.value && (E.value = false, window.requestAnimationFrame(() => {
      E.value = true, O();
    }));
  }, { flush: "sync" });
  const A = {
    referenceRef: t,
    placement: g
  }, R2 = {
    floatingRef: n,
    props: i,
    mounted: r,
    show: e,
    x: h,
    y: v,
    placement: g,
    strategy: x,
    referenceElWidth: w,
    updateFloating: O
  }, T = {
    ref: u,
    placement: g,
    x: m,
    y: d
  };
  return Ut(xn, T), { referenceApi: A, floatingApi: R2, arrowApi: T, x: h, y: v, placement: g, strategy: x, referenceEl: p, floatingEl: f, middlewareData: b, update: O };
}
__name(Cn, "Cn");
({
  ...y.as
});
var On2 = {
  as: y.as,
  show: y.show,
  placement: y.placement,
  strategy: y.strategy,
  offset: y.offset,
  shift: y.shift,
  flip: y.flip,
  arrow: y.arrow,
  autoPlacement: y.autoPlacement,
  hide: y.hide,
  autoUpdate: y.autoUpdate,
  zIndex: y.zIndex,
  transitionName: y.transitionName,
  transitionType: y.transitionType,
  enter: y.enter,
  enterFrom: y.enterFrom,
  enterTo: y.enterTo,
  leave: y.leave,
  leaveFrom: y.leaveFrom,
  leaveTo: y.leaveTo,
  originClass: y.originClass,
  tailwindcssOriginClass: y.tailwindcssOriginClass,
  portal: y.portal,
  transform: y.transform,
  middleware: y.middleware
};
var En = {
  name: "FloatVirtual",
  inheritAttrs: false,
  props: On2,
  emits: ["initial", "show", "hide", "update"],
  setup(e, { emit: t, slots: n, attrs: i }) {
    var m;
    const o = ge((m = e.show) != null ? m : false), r = ge({
      getBoundingClientRect() {
        return {
          x: 0,
          y: 0,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    }), s = ge(null), {
      floatingApi: l,
      placement: c
    } = Cn(o, r, s, e, t);
    Yt(() => e.show, () => {
      var d;
      o.value = (d = e.show) != null ? d : false;
    });
    function u() {
      o.value = false;
    }
    __name(u, "u");
    return t("initial", {
      show: o,
      placement: c,
      reference: r,
      floating: s
    }), () => {
      if (!n.default)
        return;
      const d = {
        placement: c.value,
        close: u
      }, [p] = Ze(n.default(d)).filter(dn);
      return bn(
        p,
        {
          as: e.as,
          show: o.value
        },
        i,
        l
      );
    };
  }
};
y.as, y.placement, y.strategy, y.offset, y.shift, {
  ...y.flip
}, y.arrow, y.autoPlacement, y.hide, y.autoUpdate, y.zIndex, y.transitionName, y.transitionType, y.enter, y.enterFrom, y.enterTo, y.leave, y.leaveFrom, y.leaveTo, y.originClass, y.tailwindcssOriginClass, y.transform, y.middleware;
var An = { class: "flex bg-white shadow-md z-10 rounded-md p-1" };
var Sn = ["onClick"];
var Rn = /* @__PURE__ */ Ye({
  __name: "StylePanel",
  setup(e) {
    const t = ge({ value: null }), n = Gr(), i = J(
      () => n.getters.onContentChange || (() => {
      })
    ), o = J(
      () => xh(n.getters.diagramElement) + iv
    ), r = J(() => n.getters.code), s = /* @__PURE__ */ __name((d) => {
      n.dispatch("updateCode", { code: d }), i.value(d);
    }, "s"), l = ge([]);
    let c;
    const u = /* @__PURE__ */ __name(({ show: d, reference: p, floating: f }) => {
      let a, h, v, g, x, b;
      n.commit("onMessageClick", (C, w) => {
        var O;
        if (a = C.value.start.start, h = rh(r.value, a), v = qO(r.value, a), g = ((O = r.value.slice(h).match(/^\s*/)) == null ? void 0 : O[0]) || "", x = v.trim().startsWith("//"), x) {
          const E = v.trimStart().slice(2).trimStart(), A = E.indexOf("["), R2 = E.indexOf("]");
          b = Boolean(A === 0 && R2), b ? l.value = E.slice(A + 1, R2).split(",").map((T) => T.trim()) : l.value = [];
        }
        p.value = {
          getBoundingClientRect: () => w.getBoundingClientRect()
        }, t.value = C, d.value = true;
      }), wn(
        f,
        () => {
          d.value = false, l.value = [];
        },
        J(() => d.value)
      ), c = /* @__PURE__ */ __name((C) => {
        var w;
        if (d.value = false, !!t.value.value)
          if (x) {
            let O = "";
            if (b) {
              let E;
              l.value.includes(C) ? E = l.value.filter((A) => A !== C) : E = [...l.value, C], O = `${g}// [${E.filter(Boolean).join(", ")}] ${v.slice(v.indexOf("]") + 1).trimStart()}`;
            } else
              O = `${g}// [${C}] ${v.slice((((w = v.match(/\/\/*/)) == null ? void 0 : w.index) || -2) + 2).trimStart()}`;
            O.endsWith(`
`) || (O += `
`), s(
              r.value.slice(0, KC(r.value, a)) + O + r.value.slice(h)
            );
          } else
            s(
              r.value.slice(0, h) + `${g}// [${C}]
` + r.value.slice(h)
            );
      }, "c");
    }, "u"), m = [
      {
        name: "bold",
        content: "B",
        class: "font-bold"
      },
      {
        name: "italic",
        content: "I",
        class: "italic"
      },
      {
        name: "underline",
        content: "U",
        class: "underline"
      },
      {
        name: "strikethrough",
        content: "S",
        class: "line-through"
      }
    ];
    return (d, p) => (R(), ke(Le(En), {
      key: "tool",
      onInitial: u,
      placement: "top",
      offset: 5,
      flip: { padding: Le(o) },
      shift: "",
      zIndex: "30"
    }, {
      default: jt(() => [
        S("div", An, [
          (R(), q(Fe, null, On(m, (f) => S("div", {
            onClick: () => Le(c)(f.class),
            key: f.name
          }, [
            S("div", {
              class: we(["w-6 mx-1 py-1 rounded-md text-black text-center cursor-pointer hover:bg-gray-200", [
                f.class,
                { "bg-gray-100": l.value.includes(f.class) }
              ]])
            }, He(f.content), 3)
          ], 8, Sn)), 64))
        ])
      ], void 0, true),
      _: 1
    }, 8, ["flip"]));
  }
});
export {
  Rn as default
};
