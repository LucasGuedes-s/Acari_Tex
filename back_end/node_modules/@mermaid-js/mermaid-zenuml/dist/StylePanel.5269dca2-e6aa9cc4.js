import { Y as nt, g as F, F as ot, G as L, x as rt, o as it, k as Oe, R as lt, j as at, A as ve, q as st, a as We, O as ct, _ as I, v as ut, V as ft, b as N, r as dt, K as pt, c as mt, f as he, n as Te, e as ze, W as He, d as vt, U as ht, s as gt, i as yt, N as Q, h as wt, Q as xt, l as te, m as bt, p as Se, t as Et, I as Rt, u as Ct } from "./zenuml-definition-fd05b1a1.js";
const Ie = ["top", "right", "bottom", "left"], Ae = ["start", "end"], $e = /* @__PURE__ */ Ie.reduce((e, t) => e.concat(t, t + "-" + Ae[0], t + "-" + Ae[1]), []), Z = Math.min, G = Math.max, ae = Math.round, le = Math.floor, _ = (e) => ({
  x: e,
  y: e
}), Ot = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Tt = {
  start: "end",
  end: "start"
};
function ye(e, t, n) {
  return G(e, Z(t, n));
}
function X(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function M(e) {
  return e.split("-")[0];
}
function W(e) {
  return e.split("-")[1];
}
function Me(e) {
  return e === "x" ? "y" : "x";
}
function xe(e) {
  return e === "y" ? "height" : "width";
}
function fe(e) {
  return ["top", "bottom"].includes(M(e)) ? "y" : "x";
}
function be(e) {
  return Me(fe(e));
}
function Ve(e, t, n) {
  n === void 0 && (n = !1);
  const r = W(e), o = be(e), i = xe(o);
  let l = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (l = ce(l)), [l, ce(l)];
}
function St(e) {
  const t = ce(e);
  return [se(e), t, se(t)];
}
function se(e) {
  return e.replace(/start|end/g, (t) => Tt[t]);
}
function At(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], l = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : l;
    default:
      return [];
  }
}
function $t(e, t, n, r) {
  const o = W(e);
  let i = At(M(e), n === "start", r);
  return o && (i = i.map((l) => l + "-" + o), t && (i = i.concat(i.map(se)))), i;
}
function ce(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Ot[t]);
}
function Ft(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Ue(e) {
  return typeof e != "number" ? Ft(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function ue(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function Fe(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = fe(t), l = be(t), a = xe(l), c = M(t), u = i === "y", d = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, m = r[a] / 2 - o[a] / 2;
  let f;
  switch (c) {
    case "top":
      f = {
        x: d,
        y: r.y - o.height
      };
      break;
    case "bottom":
      f = {
        x: d,
        y: r.y + r.height
      };
      break;
    case "right":
      f = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      f = {
        x: r.x - o.width,
        y: p
      };
      break;
    default:
      f = {
        x: r.x,
        y: r.y
      };
  }
  switch (W(t)) {
    case "start":
      f[l] -= m * (n && u ? -1 : 1);
      break;
    case "end":
      f[l] += m * (n && u ? -1 : 1);
      break;
  }
  return f;
}
const Lt = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: l
  } = n, a = i.filter(Boolean), c = await (l.isRTL == null ? void 0 : l.isRTL(t));
  let u = await l.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: d,
    y: p
  } = Fe(u, r, c), m = r, f = {}, s = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: g,
      fn: h
    } = a[v], {
      x: y,
      y: x,
      data: b,
      reset: w
    } = await h({
      x: d,
      y: p,
      initialPlacement: r,
      placement: m,
      strategy: o,
      middlewareData: f,
      rects: u,
      platform: l,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (d = y ?? d, p = x ?? p, f = {
      ...f,
      [g]: {
        ...f[g],
        ...b
      }
    }, w && s <= 50) {
      s++, typeof w == "object" && (w.placement && (m = w.placement), w.rects && (u = w.rects === !0 ? await l.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : w.rects), {
        x: d,
        y: p
      } = Fe(u, m, c)), v = -1;
      continue;
    }
  }
  return {
    x: d,
    y: p,
    placement: m,
    strategy: o,
    middlewareData: f
  };
};
async function ne(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: l,
    elements: a,
    strategy: c
  } = e, {
    boundary: u = "clippingAncestors",
    rootBoundary: d = "viewport",
    elementContext: p = "floating",
    altBoundary: m = !1,
    padding: f = 0
  } = X(t, e), s = Ue(f), v = a[m ? p === "floating" ? "reference" : "floating" : p], g = ue(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: u,
    rootBoundary: d,
    strategy: c
  })), h = p === "floating" ? {
    ...l.floating,
    x: r,
    y: o
  } : l.reference, y = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), x = await (i.isElement == null ? void 0 : i.isElement(y)) ? await (i.getScale == null ? void 0 : i.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, b = ue(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: h,
    offsetParent: y,
    strategy: c
  }) : h);
  return {
    top: (g.top - b.top + s.top) / x.y,
    bottom: (b.bottom - g.bottom + s.bottom) / x.y,
    left: (g.left - b.left + s.left) / x.x,
    right: (b.right - g.right + s.right) / x.x
  };
}
const Pt = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: l,
      elements: a,
      middlewareData: c
    } = t, {
      element: u,
      padding: d = 0
    } = X(e, t) || {};
    if (u == null)
      return {};
    const p = Ue(d), m = {
      x: n,
      y: r
    }, f = be(o), s = xe(f), v = await l.getDimensions(u), g = f === "y", h = g ? "top" : "left", y = g ? "bottom" : "right", x = g ? "clientHeight" : "clientWidth", b = i.reference[s] + i.reference[f] - m[f] - i.floating[s], w = m[f] - i.reference[f], R = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(u));
    let C = R ? R[x] : 0;
    (!C || !await (l.isElement == null ? void 0 : l.isElement(R))) && (C = a.floating[x] || i.floating[s]);
    const E = b / 2 - w / 2, O = C / 2 - v[s] / 2 - 1, A = Z(p[h], O), S = Z(p[y], O), $ = A, q = C - v[s] - S, P = C / 2 - v[s] / 2 + E, D = ye($, P, q), j = !c.arrow && W(o) != null && P != D && i.reference[s] / 2 - (P < $ ? A : S) - v[s] / 2 < 0, H = j ? P < $ ? P - $ : P - q : 0;
    return {
      [f]: m[f] + H,
      data: {
        [f]: D,
        centerOffset: P - D - H,
        ...j && {
          alignmentOffset: H
        }
      },
      reset: j
    };
  }
});
function Bt(e, t, n) {
  return (e ? [...n.filter((r) => W(r) === e), ...n.filter((r) => W(r) !== e)] : n.filter((r) => M(r) === r)).filter((r) => e ? W(r) === e || (t ? se(r) !== r : !1) : !0);
}
const kt = function(e) {
  return e === void 0 && (e = {}), {
    name: "autoPlacement",
    options: e,
    async fn(t) {
      var n, r, o;
      const {
        rects: i,
        middlewareData: l,
        placement: a,
        platform: c,
        elements: u
      } = t, {
        crossAxis: d = !1,
        alignment: p,
        allowedPlacements: m = $e,
        autoAlignment: f = !0,
        ...s
      } = X(e, t), v = p !== void 0 || m === $e ? Bt(p || null, f, m) : m, g = await ne(t, s), h = ((n = l.autoPlacement) == null ? void 0 : n.index) || 0, y = v[h];
      if (y == null)
        return {};
      const x = Ve(y, i, await (c.isRTL == null ? void 0 : c.isRTL(u.floating)));
      if (a !== y)
        return {
          reset: {
            placement: v[0]
          }
        };
      const b = [g[M(y)], g[x[0]], g[x[1]]], w = [...((r = l.autoPlacement) == null ? void 0 : r.overflows) || [], {
        placement: y,
        overflows: b
      }], R = v[h + 1];
      if (R)
        return {
          data: {
            index: h + 1,
            overflows: w
          },
          reset: {
            placement: R
          }
        };
      const C = w.map((O) => {
        const A = W(O.placement);
        return [O.placement, A && d ? O.overflows.slice(0, 2).reduce((S, $) => S + $, 0) : O.overflows[0], O.overflows];
      }).sort((O, A) => O[1] - A[1]), E = ((o = C.filter((O) => O[2].slice(
        0,
        W(O[0]) ? 2 : 3
      ).every((A) => A <= 0))[0]) == null ? void 0 : o[0]) || C[0][0];
      return E !== a ? {
        data: {
          index: h + 1,
          overflows: w
        },
        reset: {
          placement: E
        }
      } : {};
    }
  };
}, Dt = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: l,
        initialPlacement: a,
        platform: c,
        elements: u
      } = t, {
        mainAxis: d = !0,
        crossAxis: p = !0,
        fallbackPlacements: m,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: s = "none",
        flipAlignment: v = !0,
        ...g
      } = X(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const h = M(o), y = M(a) === a, x = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), b = m || (y || !v ? [ce(a)] : St(a));
      !m && s !== "none" && b.push(...$t(a, v, s, x));
      const w = [a, ...b], R = await ne(t, g), C = [];
      let E = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (d && C.push(R[h]), p) {
        const $ = Ve(o, l, x);
        C.push(R[$[0]], R[$[1]]);
      }
      if (E = [...E, {
        placement: o,
        overflows: C
      }], !C.every(($) => $ <= 0)) {
        var O, A;
        const $ = (((O = i.flip) == null ? void 0 : O.index) || 0) + 1, q = w[$];
        if (q)
          return {
            data: {
              index: $,
              overflows: E
            },
            reset: {
              placement: q
            }
          };
        let P = (A = E.filter((D) => D.overflows[0] <= 0).sort((D, j) => D.overflows[1] - j.overflows[1])[0]) == null ? void 0 : A.placement;
        if (!P)
          switch (f) {
            case "bestFit": {
              var S;
              const D = (S = E.map((j) => [j.placement, j.overflows.filter((H) => H > 0).reduce((H, tt) => H + tt, 0)]).sort((j, H) => j[1] - H[1])[0]) == null ? void 0 : S[0];
              D && (P = D);
              break;
            }
            case "initialPlacement":
              P = a;
              break;
          }
        if (o !== P)
          return {
            reset: {
              placement: P
            }
          };
      }
      return {};
    }
  };
};
function Le(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Pe(e) {
  return Ie.some((t) => e[t] >= 0);
}
const jt = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = X(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await ne(t, {
            ...o,
            elementContext: "reference"
          }), l = Le(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: Pe(l)
            }
          };
        }
        case "escaped": {
          const i = await ne(t, {
            ...o,
            altBoundary: !0
          }), l = Le(i, n.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: Pe(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function Nt(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), l = M(n), a = W(n), c = fe(n) === "y", u = ["left", "top"].includes(l) ? -1 : 1, d = i && c ? -1 : 1, p = X(t, e);
  let {
    mainAxis: m,
    crossAxis: f,
    alignmentAxis: s
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...p
  };
  return a && typeof s == "number" && (f = a === "end" ? s * -1 : s), c ? {
    x: f * d,
    y: m * u
  } : {
    x: m * u,
    y: f * d
  };
}
const Wt = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r
      } = t, o = await Nt(t, e);
      return {
        x: n + o.x,
        y: r + o.y,
        data: o
      };
    }
  };
}, zt = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: l = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: h,
              y
            } = g;
            return {
              x: h,
              y
            };
          }
        },
        ...c
      } = X(e, t), u = {
        x: n,
        y: r
      }, d = await ne(t, c), p = fe(M(o)), m = Me(p);
      let f = u[m], s = u[p];
      if (i) {
        const g = m === "y" ? "top" : "left", h = m === "y" ? "bottom" : "right", y = f + d[g], x = f - d[h];
        f = ye(y, f, x);
      }
      if (l) {
        const g = p === "y" ? "top" : "left", h = p === "y" ? "bottom" : "right", y = s + d[g], x = s - d[h];
        s = ye(y, s, x);
      }
      const v = a.fn({
        ...t,
        [m]: f,
        [p]: s
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r
        }
      };
    }
  };
};
function Y(e) {
  return _e(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function B(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function U(e) {
  var t;
  return (t = (_e(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function _e(e) {
  return e instanceof Node || e instanceof B(e).Node;
}
function V(e) {
  return e instanceof Element || e instanceof B(e).Element;
}
function z(e) {
  return e instanceof HTMLElement || e instanceof B(e).HTMLElement;
}
function Be(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof B(e).ShadowRoot;
}
function ie(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = k(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function Ht(e) {
  return ["table", "td", "th"].includes(Y(e));
}
function Ee(e) {
  const t = Re(), n = k(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function It(e) {
  let t = ee(e);
  for (; z(t) && !de(t); ) {
    if (Ee(t))
      return t;
    t = ee(t);
  }
  return null;
}
function Re() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function de(e) {
  return ["html", "body", "#document"].includes(Y(e));
}
function k(e) {
  return B(e).getComputedStyle(e);
}
function pe(e) {
  return V(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function ee(e) {
  if (Y(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || Be(e) && e.host || U(e);
  return Be(t) ? t.host : t;
}
function Ye(e) {
  const t = ee(e);
  return de(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : z(t) && ie(t) ? t : Ye(t);
}
function oe(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = Ye(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), l = B(o);
  return i ? t.concat(l, l.visualViewport || [], ie(o) ? o : [], l.frameElement && n ? oe(l.frameElement) : []) : t.concat(o, oe(o, [], n));
}
function qe(e) {
  const t = k(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = z(e), i = o ? e.offsetWidth : n, l = o ? e.offsetHeight : r, a = ae(n) !== i || ae(r) !== l;
  return a && (n = i, r = l), {
    width: n,
    height: r,
    $: a
  };
}
function Ce(e) {
  return V(e) ? e : e.contextElement;
}
function J(e) {
  const t = Ce(e);
  if (!z(t))
    return _(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = qe(t);
  let l = (i ? ae(n.width) : n.width) / r, a = (i ? ae(n.height) : n.height) / o;
  return (!l || !Number.isFinite(l)) && (l = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: l,
    y: a
  };
}
const Mt = /* @__PURE__ */ _(0);
function Ge(e) {
  const t = B(e);
  return !Re() || !t.visualViewport ? Mt : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Vt(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== B(e) ? !1 : t;
}
function K(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = Ce(e);
  let l = _(1);
  t && (r ? V(r) && (l = J(r)) : l = J(e));
  const a = Vt(i, n, r) ? Ge(i) : _(0);
  let c = (o.left + a.x) / l.x, u = (o.top + a.y) / l.y, d = o.width / l.x, p = o.height / l.y;
  if (i) {
    const m = B(i), f = r && V(r) ? B(r) : r;
    let s = m.frameElement;
    for (; s && r && f !== m; ) {
      const v = J(s), g = s.getBoundingClientRect(), h = k(s), y = g.left + (s.clientLeft + parseFloat(h.paddingLeft)) * v.x, x = g.top + (s.clientTop + parseFloat(h.paddingTop)) * v.y;
      c *= v.x, u *= v.y, d *= v.x, p *= v.y, c += y, u += x, s = B(s).frameElement;
    }
  }
  return ue({
    width: d,
    height: p,
    x: c,
    y: u
  });
}
function Ut(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: r
  } = e;
  const o = z(n), i = U(n);
  if (n === i)
    return t;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, a = _(1);
  const c = _(0);
  if ((o || !o && r !== "fixed") && ((Y(n) !== "body" || ie(i)) && (l = pe(n)), z(n))) {
    const u = K(n);
    a = J(n), c.x = u.x + n.clientLeft, c.y = u.y + n.clientTop;
  }
  return {
    width: t.width * a.x,
    height: t.height * a.y,
    x: t.x * a.x - l.scrollLeft * a.x + c.x,
    y: t.y * a.y - l.scrollTop * a.y + c.y
  };
}
function _t(e) {
  return Array.from(e.getClientRects());
}
function Ke(e) {
  return K(U(e)).left + pe(e).scrollLeft;
}
function Yt(e) {
  const t = U(e), n = pe(e), r = e.ownerDocument.body, o = G(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = G(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -n.scrollLeft + Ke(e);
  const a = -n.scrollTop;
  return k(r).direction === "rtl" && (l += G(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: l,
    y: a
  };
}
function qt(e, t) {
  const n = B(e), r = U(e), o = n.visualViewport;
  let i = r.clientWidth, l = r.clientHeight, a = 0, c = 0;
  if (o) {
    i = o.width, l = o.height;
    const u = Re();
    (!u || u && t === "fixed") && (a = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: i,
    height: l,
    x: a,
    y: c
  };
}
function Gt(e, t) {
  const n = K(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = z(e) ? J(e) : _(1), l = e.clientWidth * i.x, a = e.clientHeight * i.y, c = o * i.x, u = r * i.y;
  return {
    width: l,
    height: a,
    x: c,
    y: u
  };
}
function ke(e, t, n) {
  let r;
  if (t === "viewport")
    r = qt(e, n);
  else if (t === "document")
    r = Yt(U(e));
  else if (V(t))
    r = Gt(t, n);
  else {
    const o = Ge(e);
    r = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return ue(r);
}
function Xe(e, t) {
  const n = ee(e);
  return n === t || !V(n) || de(n) ? !1 : k(n).position === "fixed" || Xe(n, t);
}
function Kt(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = oe(e, [], !1).filter((a) => V(a) && Y(a) !== "body"), o = null;
  const i = k(e).position === "fixed";
  let l = i ? ee(e) : e;
  for (; V(l) && !de(l); ) {
    const a = k(l), c = Ee(l);
    !c && a.position === "fixed" && (o = null), (i ? !c && !o : !c && a.position === "static" && o && ["absolute", "fixed"].includes(o.position) || ie(l) && !c && Xe(e, l)) ? r = r.filter((u) => u !== l) : o = a, l = ee(l);
  }
  return t.set(e, r), r;
}
function Xt(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const i = [...n === "clippingAncestors" ? Kt(t, this._c) : [].concat(n), r], l = i[0], a = i.reduce((c, u) => {
    const d = ke(t, u, o);
    return c.top = G(d.top, c.top), c.right = Z(d.right, c.right), c.bottom = Z(d.bottom, c.bottom), c.left = G(d.left, c.left), c;
  }, ke(t, l, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function Qt(e) {
  return qe(e);
}
function Jt(e, t, n) {
  const r = z(t), o = U(t), i = n === "fixed", l = K(e, !0, i, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = _(0);
  if (r || !r && !i)
    if ((Y(t) !== "body" || ie(o)) && (a = pe(t)), r) {
      const u = K(t, !0, i, t);
      c.x = u.x + t.clientLeft, c.y = u.y + t.clientTop;
    } else
      o && (c.x = Ke(o));
  return {
    x: l.left + a.scrollLeft - c.x,
    y: l.top + a.scrollTop - c.y,
    width: l.width,
    height: l.height
  };
}
function De(e, t) {
  return !z(e) || k(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function Qe(e, t) {
  const n = B(e);
  if (!z(e))
    return n;
  let r = De(e, t);
  for (; r && Ht(r) && k(r).position === "static"; )
    r = De(r, t);
  return r && (Y(r) === "html" || Y(r) === "body" && k(r).position === "static" && !Ee(r)) ? n : r || It(e) || n;
}
const Zt = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: r
  } = e;
  const o = this.getOffsetParent || Qe, i = this.getDimensions;
  return {
    reference: Jt(t, await o(n), r),
    floating: {
      x: 0,
      y: 0,
      ...await i(n)
    }
  };
};
function en(e) {
  return k(e).direction === "rtl";
}
const tn = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Ut,
  getDocumentElement: U,
  getClippingRect: Xt,
  getOffsetParent: Qe,
  getElementRects: Zt,
  getClientRects: _t,
  getDimensions: Qt,
  getScale: J,
  isElement: V,
  isRTL: en
};
function nn(e, t) {
  let n = null, r;
  const o = U(e);
  function i() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function l(a, c) {
    a === void 0 && (a = !1), c === void 0 && (c = 1), i();
    const {
      left: u,
      top: d,
      width: p,
      height: m
    } = e.getBoundingClientRect();
    if (a || t(), !p || !m)
      return;
    const f = le(d), s = le(o.clientWidth - (u + p)), v = le(o.clientHeight - (d + m)), g = le(u), h = {
      rootMargin: -f + "px " + -s + "px " + -v + "px " + -g + "px",
      threshold: G(0, Z(1, c)) || 1
    };
    let y = !0;
    function x(b) {
      const w = b[0].intersectionRatio;
      if (w !== c) {
        if (!y)
          return l();
        w ? l(!1, w) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 100);
      }
      y = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...h,
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, h);
    }
    n.observe(e);
  }
  return l(!0), i;
}
function on(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, u = Ce(e), d = o || i ? [...u ? oe(u) : [], ...oe(t)] : [];
  d.forEach((h) => {
    o && h.addEventListener("scroll", n, {
      passive: !0
    }), i && h.addEventListener("resize", n);
  });
  const p = u && a ? nn(u, n) : null;
  let m = -1, f = null;
  l && (f = new ResizeObserver((h) => {
    let [y] = h;
    y && y.target === u && f && (f.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      f && f.observe(t);
    })), n();
  }), u && !c && f.observe(u), f.observe(t));
  let s, v = c ? K(e) : null;
  c && g();
  function g() {
    const h = K(e);
    v && (h.x !== v.x || h.y !== v.y || h.width !== v.width || h.height !== v.height) && n(), v = h, s = requestAnimationFrame(g);
  }
  return n(), () => {
    d.forEach((h) => {
      o && h.removeEventListener("scroll", n), i && h.removeEventListener("resize", n);
    }), p && p(), f && f.disconnect(), f = null, c && cancelAnimationFrame(s);
  };
}
const rn = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: tn,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return Lt(e, t, {
    ...o,
    platform: i
  });
};
function we(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function ln(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = we(I(e.element));
      return n == null ? {} : Pt({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function an(e, t, n) {
  n === void 0 && (n = {});
  const r = n.whileElementsMounted, o = L(() => {
    var w;
    return (w = I(n.open)) != null ? w : !0;
  }), i = L(() => I(n.middleware)), l = L(() => {
    var w;
    return (w = I(n.placement)) != null ? w : "bottom";
  }), a = L(() => {
    var w;
    return (w = I(n.strategy)) != null ? w : "absolute";
  }), c = L(() => we(e.value)), u = L(() => we(t.value)), d = F(null), p = F(null), m = F(a.value), f = F(l.value), s = ze({}), v = F(!1);
  let g;
  function h() {
    c.value == null || u.value == null || rn(c.value, u.value, {
      middleware: i.value,
      placement: l.value,
      strategy: a.value
    }).then((w) => {
      d.value = w.x, p.value = w.y, m.value = w.strategy, f.value = w.placement, s.value = w.middlewareData, v.value = !0;
    });
  }
  function y() {
    typeof g == "function" && (g(), g = void 0);
  }
  function x() {
    if (y(), r === void 0) {
      h();
      return;
    }
    if (c.value != null && u.value != null) {
      g = r(c.value, u.value, h);
      return;
    }
  }
  function b() {
    o.value || (v.value = !1);
  }
  return N([i, l, a], h, {
    flush: "sync"
  }), N([c, u], x, {
    flush: "sync"
  }), N(o, b, {
    flush: "sync"
  }), gt() && yt(y), {
    x: Q(d),
    y: Q(p),
    strategy: Q(m),
    placement: Q(f),
    middlewareData: Q(s),
    isPositioned: Q(v),
    update: h
  };
}
var sn = Object.defineProperty, cn = (e, t, n) => t in e ? sn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, un = (e, t, n) => (cn(e, typeof t != "symbol" ? t + "" : t, n), n);
function re(e) {
  var t;
  if (e == null || e.value == null)
    return null;
  const n = (t = e.value.$el) != null ? t : e.value;
  return n.$el ? re(F(n)) : n;
}
class fn {
  constructor() {
    un(this, "current", this.detect());
  }
  set(t) {
    this.current !== t && (this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
}
const me = new fn();
function Je(e) {
  return e.reduce((t, n) => n.type === We ? t.concat(Je(n.children)) : t.concat(n), []);
}
function dn(e) {
  return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function";
}
function je(e) {
  return e = I(e), e && (e == null ? void 0 : e.nodeType) !== Node.COMMENT_NODE;
}
function pn(e) {
  if (me.isServer)
    return null;
  if (e instanceof Node)
    return e.ownerDocument;
  if (Object.prototype.hasOwnProperty.call(e, "value")) {
    const t = re(e);
    if (t)
      return t.ownerDocument;
  }
  return document;
}
function mn(e, t, n, r, o) {
  N([
    () => o.offset,
    () => o.flip,
    () => o.shift,
    () => o.autoPlacement,
    () => o.arrow,
    () => o.hide,
    () => o.middleware
  ], () => {
    const i = [];
    (typeof o.offset == "number" || typeof o.offset == "object" || typeof o.offset == "function") && i.push(Wt(o.offset)), (o.flip === !0 || typeof o.flip == "number" || typeof o.flip == "object") && i.push(Dt({
      padding: typeof o.flip == "number" ? o.flip : void 0,
      ...typeof o.flip == "object" ? o.flip : {}
    })), (o.shift === !0 || typeof o.shift == "number" || typeof o.shift == "object") && i.push(zt({
      padding: typeof o.shift == "number" ? o.shift : void 0,
      ...typeof o.shift == "object" ? o.shift : {}
    })), (o.autoPlacement === !0 || typeof o.autoPlacement == "object") && i.push(kt(
      typeof o.autoPlacement == "object" ? o.autoPlacement : void 0
    )), (o.arrow === !0 || typeof o.arrow == "number") && i.push(ln({
      element: r,
      padding: o.arrow === !0 ? 0 : o.arrow
    })), i.push(...typeof o.middleware == "function" ? o.middleware({
      referenceEl: t,
      floatingEl: n
    }) : o.middleware || []), (o.hide === !0 || typeof o.hide == "object") && i.push(jt(
      typeof o.hide == "object" ? o.hide : void 0
    )), e.value = i;
  }, { immediate: !0 });
}
function vn(e, t, n) {
  let r = () => {
  };
  He(() => {
    if (e && me.isClient && typeof ResizeObserver < "u" && t.value && t.value instanceof Element) {
      const o = new ResizeObserver(([i]) => {
        n.value = i.borderBoxSize.reduce((l, { inlineSize: a }) => l + a, 0);
      });
      o.observe(t.value), r = () => {
        o.disconnect(), n.value = null;
      };
    }
  }), wt(() => {
    r();
  });
}
const hn = (e) => {
  switch (e) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "";
  }
};
function gn(e, t) {
  const n = L(() => {
    if (typeof e.originClass == "function")
      return e.originClass(t.value);
    if (typeof e.originClass == "string")
      return e.originClass;
    if (e.tailwindcssOriginClass)
      return hn(t.value);
  }), r = L(
    () => e.enter || n.value ? `${e.enter || ""} ${n.value || ""}` : void 0
  ), o = L(
    () => e.leave || n.value ? `${e.leave || ""} ${n.value || ""}` : void 0
  );
  return { originClassRef: n, enterActiveClassRef: r, leaveActiveClassRef: o };
}
function Ze(e, t, ...n) {
  if (e in t) {
    const o = t[e];
    return typeof o == "function" ? o(...n) : o;
  }
  const r = new Error(
    `Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      t
    ).map((o) => `"${o}"`).join(", ")}.`
  );
  throw Error.captureStackTrace && Error.captureStackTrace(r, Ze), r;
}
const Ne = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(
  (e) => `${e}:not([tabindex='-1'])`
).join(",");
var et = /* @__PURE__ */ ((e) => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(et || {});
function yn(e, t = 0) {
  var n;
  return e === ((n = pn(e)) == null ? void 0 : n.body) ? !1 : Ze(t, {
    0() {
      return e.matches(Ne);
    },
    1() {
      let r = e;
      for (; r !== null; ) {
        if (r.matches(Ne))
          return !0;
        r = r.parentElement;
      }
      return !1;
    }
  });
}
function ge(e, t, n) {
  me.isServer || xt((r) => {
    document.addEventListener(e, t, n), r(() => document.removeEventListener(e, t, n));
  });
}
function wn(e, t, n = L(() => !0)) {
  function r(i, l) {
    if (!n.value || i.defaultPrevented)
      return;
    const a = l(i);
    if (a === null || !a.getRootNode().contains(a))
      return;
    const c = function u(d) {
      return typeof d == "function" ? u(d()) : Array.isArray(d) || d instanceof Set ? d : [d];
    }(e);
    for (const u of c) {
      if (u === null)
        continue;
      const d = u instanceof HTMLElement ? u : re(u);
      if (d != null && d.contains(a) || i.composed && i.composedPath().includes(d))
        return;
    }
    return !yn(a, et.Loose) && a.tabIndex !== -1 && i.preventDefault(), t(i, a);
  }
  const o = F(null);
  ge("mousedown", (i) => {
    var l, a;
    n.value && (o.value = ((a = (l = i.composedPath) == null ? void 0 : l.call(i)) == null ? void 0 : a[0]) || i.target);
  }, !0), ge(
    "click",
    (i) => {
      o.value && (r(i, () => o.value), o.value = null);
    },
    !0
  ), ge("blur", (i) => r(
    i,
    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null
  ), !0);
}
const xn = Symbol("ArrowContext"), T = {
  as: {
    type: [String, Function],
    default: "template"
  },
  floatingAs: {
    type: [String, Function],
    default: "div"
  },
  show: {
    type: Boolean,
    default: null
  },
  placement: {
    type: String,
    default: "bottom-start"
  },
  strategy: {
    type: String,
    default: "absolute"
  },
  offset: [Number, Function, Object],
  shift: {
    type: [Boolean, Number, Object],
    default: !1
  },
  flip: {
    type: [Boolean, Number, Object],
    default: !1
  },
  arrow: {
    type: [Boolean, Number],
    default: !1
  },
  autoPlacement: {
    type: [Boolean, Object],
    default: !1
  },
  hide: {
    type: [Boolean, Object],
    default: !1
  },
  autoUpdate: {
    type: [Boolean, Object],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 9999
  },
  transitionName: String,
  transitionType: String,
  enter: String,
  enterFrom: String,
  enterTo: String,
  leave: String,
  leaveFrom: String,
  leaveTo: String,
  originClass: [String, Function],
  tailwindcssOriginClass: {
    type: Boolean,
    default: !1
  },
  portal: {
    type: Boolean,
    default: !1
  },
  transform: {
    type: Boolean,
    default: !0
  },
  adaptiveWidth: {
    type: Boolean,
    default: !1
  },
  composable: {
    type: Boolean,
    default: !1
  },
  dialog: {
    type: Boolean,
    default: !1
  },
  middleware: {
    type: [Array, Function],
    default: () => []
  }
};
function bn(e, t, n, r) {
  const { floatingRef: o, props: i, mounted: l, show: a, x: c, y: u, placement: d, strategy: p, referenceElWidth: m, updateFloating: f } = r, s = he(
    { ...i, as: i.floatingAs },
    t
  ), { enterActiveClassRef: v, leaveActiveClassRef: g } = gn(s, d), h = {
    enterActiveClass: v.value,
    enterFromClass: s.enterFrom,
    enterToClass: s.enterTo,
    leaveActiveClass: g.value,
    leaveFromClass: s.leaveFrom,
    leaveToClass: s.leaveTo
  }, y = {
    name: s.transitionName,
    type: s.transitionType,
    appear: !0,
    ...s.transitionName ? {} : h,
    onBeforeEnter() {
      a.value = !0;
    },
    onAfterLeave() {
      a.value = !1;
    }
  }, x = {
    enter: v.value,
    enterFrom: s.enterFrom,
    enterTo: s.enterTo,
    leave: g.value,
    leaveFrom: s.leaveFrom,
    leaveTo: s.leaveTo,
    onBeforeEnter: y.onBeforeEnter,
    onAfterLeave: y.onAfterLeave
  }, b = {
    style: {
      ...!s.dialog && s.transform ? {
        position: p.value,
        zIndex: s.zIndex,
        top: "0px",
        left: "0px",
        right: "auto",
        bottom: "auto",
        transform: `translate(${Math.round(c.value || 0)}px,${Math.round(u.value || 0)}px)`
      } : {
        position: p.value,
        zIndex: s.zIndex,
        top: `${u.value || 0}px`,
        left: `${c.value || 0}px`
      },
      width: s.adaptiveWidth && typeof m.value == "number" ? `${m.value}px` : void 0
    }
  };
  function w(E) {
    return s.portal ? te(bt, () => E) : E;
  }
  function R(E) {
    const O = he(
      b,
      n,
      s.dialog ? {} : { ref: o }
    );
    return s.as === "template" ? E : typeof s.as == "string" ? te(s.as, O, E) : te(s.as, O, () => E);
  }
  function C() {
    function E() {
      var O;
      const A = s.as === "template" ? he(
        b,
        n,
        s.dialog ? {} : { ref: o }
      ) : null, S = Ct(e, A);
      return ((O = S.props) == null ? void 0 : O.unmount) === !1 ? (f(), S) : typeof s.show != "boolean" || s.show ? S : Se();
    }
    return me.isServer ? l.value && s.show ? E() : Se() : s.transitionChild ? te(Et, {
      key: `placement-${d.value}`,
      ...s.dialog ? { ref: o } : {},
      as: "template",
      ...x
    }, E) : te(Rt, {
      ...s.dialog ? { ref: o } : {},
      ...y
    }, E);
  }
  return w(
    R(
      C()
    )
  );
}
function En(e, t, n, r, o) {
  const i = F(!1), l = Te(r, "placement"), a = Te(r, "strategy"), c = ze({}), u = F(null), d = F(void 0), p = F(void 0), m = L(() => re(t)), f = L(() => re(n)), s = L(
    () => je(m) && je(f)
  ), { x: v, y: g, placement: h, strategy: y, middlewareData: x, update: b } = an(m, f, {
    placement: l,
    strategy: a,
    middleware: c,
    whileElementsMounted: () => {
    }
  }), w = F(null);
  He(() => {
    i.value = !0;
  }), N(e, (S, $) => {
    S && !$ ? o("show") : !S && $ && o("hide");
  }, { immediate: !0 });
  function R() {
    s.value && (b(), o("update"));
  }
  N([l, a, c], R, { flush: "sync" }), mn(
    c,
    m,
    f,
    u,
    r
  ), N(x, () => {
    const S = x.value.arrow;
    d.value = S == null ? void 0 : S.x, p.value = S == null ? void 0 : S.y;
  }), vn(r.adaptiveWidth, m, w), N(e, async (S, $, q) => {
    if (await vt(), e.value && s.value && r.autoUpdate) {
      const P = on(
        m.value,
        f.value,
        R,
        typeof r.autoUpdate == "object" ? r.autoUpdate : void 0
      );
      q(P);
    }
  }, { flush: "post", immediate: !0 });
  const C = F(!0);
  N(m, () => {
    !(m.value instanceof Element) && s.value && C.value && (C.value = !1, window.requestAnimationFrame(() => {
      C.value = !0, R();
    }));
  }, { flush: "sync" });
  const E = {
    referenceRef: t,
    placement: h
  }, O = {
    floatingRef: n,
    props: r,
    mounted: i,
    show: e,
    x: v,
    y: g,
    placement: h,
    strategy: y,
    referenceElWidth: w,
    updateFloating: R
  }, A = {
    ref: u,
    placement: h,
    x: d,
    y: p
  };
  return ht(xn, A), { referenceApi: E, floatingApi: O, arrowApi: A, x: v, y: g, placement: h, strategy: y, referenceEl: m, floatingEl: f, middlewareData: x, update: R };
}
({
  ...T.as
});
const Rn = {
  as: T.as,
  show: T.show,
  placement: T.placement,
  strategy: T.strategy,
  offset: T.offset,
  shift: T.shift,
  flip: T.flip,
  arrow: T.arrow,
  autoPlacement: T.autoPlacement,
  hide: T.hide,
  autoUpdate: T.autoUpdate,
  zIndex: T.zIndex,
  transitionName: T.transitionName,
  transitionType: T.transitionType,
  enter: T.enter,
  enterFrom: T.enterFrom,
  enterTo: T.enterTo,
  leave: T.leave,
  leaveFrom: T.leaveFrom,
  leaveTo: T.leaveTo,
  originClass: T.originClass,
  tailwindcssOriginClass: T.tailwindcssOriginClass,
  portal: T.portal,
  transform: T.transform,
  middleware: T.middleware
}, Cn = {
  name: "FloatVirtual",
  inheritAttrs: !1,
  props: Rn,
  emits: ["initial", "show", "hide", "update"],
  setup(e, { emit: t, slots: n, attrs: r }) {
    var o;
    const i = F((o = e.show) != null ? o : !1), l = F({
      getBoundingClientRect() {
        return {
          x: 0,
          y: 0,
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          width: 0,
          height: 0
        };
      }
    }), a = F(null), {
      floatingApi: c,
      placement: u
    } = En(i, l, a, e, t);
    N(() => e.show, () => {
      var p;
      i.value = (p = e.show) != null ? p : !1;
    });
    function d() {
      i.value = !1;
    }
    return t("initial", {
      show: i,
      placement: u,
      reference: l,
      floating: a
    }), () => {
      if (!n.default)
        return;
      const p = {
        placement: u.value,
        close: d
      }, [m] = Je(n.default(p)).filter(dn);
      return bn(
        m,
        {
          as: e.as,
          show: i.value
        },
        r,
        c
      );
    };
  }
};
({
  ...T.flip
});
const On = { class: "flex bg-white shadow-md z-10 rounded-md p-1" }, Tn = ["onClick"], An = /* @__PURE__ */ nt({
  __name: "StylePanel",
  setup(e) {
    const t = F({ value: null }), n = ot(), r = L(
      () => n.getters.onContentChange || (() => {
      })
    ), o = L(
      () => rt(n.getters.diagramElement) + it
    ), i = L(() => n.getters.code), l = (p) => {
      n.dispatch("updateCode", { code: p }), r.value(p);
    }, a = F([]);
    let c;
    const u = ({ show: p, reference: m, floating: f }) => {
      let s, v, g, h, y, x;
      n.commit("onMessageClick", (b, w) => {
        var R;
        if (s = b.value.start.start, v = dt(i.value, s), g = pt(i.value, s), h = ((R = i.value.slice(v).match(/^\s*/)) == null ? void 0 : R[0]) || "", y = g.trim().startsWith("//"), y) {
          const C = g.trimStart().slice(2).trimStart(), E = C.indexOf("["), O = C.indexOf("]");
          x = !!(E === 0 && O), x ? a.value = C.slice(E + 1, O).split(",").map((A) => A.trim()) : a.value = [];
        }
        m.value = {
          getBoundingClientRect: () => w.getBoundingClientRect()
        }, t.value = b, p.value = !0;
      }), wn(
        f,
        () => {
          p.value = !1, a.value = [];
        },
        L(() => p.value)
      ), c = (b) => {
        var w;
        if (p.value = !1, !!t.value.value)
          if (y) {
            let R = "";
            if (x) {
              let C;
              a.value.includes(b) ? C = a.value.filter((E) => E !== b) : C = [...a.value, b], R = `${h}// [${C.filter(Boolean).join(", ")}] ${g.slice(g.indexOf("]") + 1).trimStart()}`;
            } else
              R = `${h}// [${b}] ${g.slice((((w = g.match(/\/\/*/)) == null ? void 0 : w.index) || -2) + 2).trimStart()}`;
            R.endsWith(`
`) || (R += `
`), l(
              i.value.slice(0, mt(i.value, s)) + R + i.value.slice(v)
            );
          } else
            l(
              i.value.slice(0, v) + `${h}// [${b}]
` + i.value.slice(v)
            );
      };
    }, d = [
      {
        name: "bold",
        content: "B",
        class: "font-bold"
      },
      {
        name: "italic",
        content: "I",
        class: "italic"
      },
      {
        name: "underline",
        content: "U",
        class: "underline"
      },
      {
        name: "strikethrough",
        content: "S",
        class: "line-through"
      }
    ];
    return (p, m) => (Oe(), lt(I(Cn), {
      key: "tool",
      onInitial: u,
      placement: "top",
      offset: 5,
      flip: { padding: I(o) },
      shift: "",
      zIndex: "30"
    }, {
      default: at(() => [
        ve("div", On, [
          (Oe(), st(We, null, ct(d, (f) => ve("div", {
            onClick: () => I(c)(f.class),
            key: f.name
          }, [
            ve("div", {
              class: ut(["w-6 mx-1 py-1 rounded-md text-black text-center cursor-pointer hover:bg-gray-200", [
                f.class,
                { "bg-gray-100": a.value.includes(f.class) }
              ]])
            }, ft(f.content), 3)
          ], 8, Tn)), 64))
        ])
      ], void 0, !0),
      _: 1
    }, 8, ["flip"]));
  }
});
export {
  An as default
};
