#!/usr/bin/env node
"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-EOPVK4AE.js
  var require_chunk_EOPVK4AE = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-EOPVK4AE.js"(exports, module) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var chunk_EOPVK4AE_exports = {};
      __export(chunk_EOPVK4AE_exports, {
        LineStream: () => LineStream,
        byline: () => byline,
        createLineStream: () => createLineStream,
        createStream: () => createStream
      });
      module.exports = __toCommonJS(chunk_EOPVK4AE_exports);
      var import_stream = __toESM2(__require("stream"));
      var import_util = __toESM2(__require("util"));
      function byline(readStream, options) {
        return createStream(readStream, options);
      }
      function createStream(readStream, options) {
        if (readStream) {
          return createLineStream(readStream, options);
        } else {
          return new LineStream(options);
        }
      }
      function createLineStream(readStream, options) {
        if (!readStream) {
          throw new Error("expected readStream");
        }
        if (!readStream.readable) {
          throw new Error("readStream must be readable");
        }
        const ls = new LineStream(options);
        readStream.pipe(ls);
        return ls;
      }
      function LineStream(options) {
        import_stream.default.Transform.call(this, options);
        options = options || {};
        this._readableState.objectMode = true;
        this._lineBuffer = [];
        this._keepEmptyLines = options.keepEmptyLines || false;
        this._lastChunkEndedWithCR = false;
        this.on("pipe", function(src) {
          if (!this.encoding) {
            if (src instanceof import_stream.default.Readable) {
              this.encoding = src._readableState.encoding;
            }
          }
        });
      }
      import_util.default.inherits(LineStream, import_stream.default.Transform);
      LineStream.prototype._transform = function(chunk, encoding, done) {
        encoding = encoding || "utf8";
        if (Buffer.isBuffer(chunk)) {
          if (encoding == "buffer") {
            chunk = chunk.toString();
            encoding = "utf8";
          } else {
            chunk = chunk.toString(encoding);
          }
        }
        this._chunkEncoding = encoding;
        const lines = chunk.split(/\r\n|\r|\n/g);
        if (this._lastChunkEndedWithCR && chunk[0] == "\n") {
          lines.shift();
        }
        if (this._lineBuffer.length > 0) {
          this._lineBuffer[this._lineBuffer.length - 1] += lines[0];
          lines.shift();
        }
        this._lastChunkEndedWithCR = chunk[chunk.length - 1] == "\r";
        this._lineBuffer = this._lineBuffer.concat(lines);
        this._pushBuffer(encoding, 1, done);
      };
      LineStream.prototype._pushBuffer = function(encoding, keep, done) {
        while (this._lineBuffer.length > keep) {
          const line = this._lineBuffer.shift();
          if (this._keepEmptyLines || line.length > 0) {
            if (!this.push(this._reencode(line, encoding))) {
              const self = this;
              setImmediate(function() {
                self._pushBuffer(encoding, keep, done);
              });
              return;
            }
          }
        }
        done();
      };
      LineStream.prototype._flush = function(done) {
        this._pushBuffer(this._chunkEncoding, 0, done);
      };
      LineStream.prototype._reencode = function(line, chunkEncoding) {
        if (this.encoding && this.encoding != chunkEncoding) {
          return Buffer.from(line, chunkEncoding).toString(this.encoding);
        } else if (this.encoding) {
          return line;
        } else {
          return Buffer.from(line, chunkEncoding);
        }
      };
    }
  });

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-QGM4M3NI.js
  var require_chunk_QGM4M3NI = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-QGM4M3NI.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var chunk_QGM4M3NI_exports = {};
      __export(chunk_QGM4M3NI_exports, {
        __commonJS: () => __commonJS2,
        __require: () => __require2,
        __toESM: () => __toESM2
      });
      module.exports = __toCommonJS(chunk_QGM4M3NI_exports);
      var __create2 = Object.create;
      var __defProp22 = Object.defineProperty;
      var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames22 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp22 = Object.prototype.hasOwnProperty;
      var __require2 = /* @__PURE__ */ ((x) => typeof __require !== "undefined" ? __require : typeof Proxy !== "undefined" ? new Proxy(x, {
        get: (a, b) => (typeof __require !== "undefined" ? __require : a)[b]
      }) : x)(function(x) {
        if (typeof __require !== "undefined") return __require.apply(this, arguments);
        throw Error('Dynamic require of "' + x + '" is not supported');
      });
      var __commonJS2 = (cb, mod) => function __require22() {
        return mod || (0, cb[__getOwnPropNames22(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
      };
      var __copyProps22 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames22(from))
            if (!__hasOwnProp22.call(to, key) && key !== except)
              __defProp22(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps22(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp22(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
    }
  });

  // node_modules/.pnpm/@prisma+debug@6.2.1/node_modules/@prisma/debug/dist/index.js
  var require_dist = __commonJS({
    "node_modules/.pnpm/@prisma+debug@6.2.1/node_modules/@prisma/debug/dist/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var src_exports = {};
      __export(src_exports, {
        Debug: () => Debug,
        clearLogs: () => clearLogs,
        default: () => src_default,
        getLogs: () => getLogs
      });
      module.exports = __toCommonJS(src_exports);
      var colors_exports = {};
      __export(colors_exports, {
        $: () => $,
        bgBlack: () => bgBlack,
        bgBlue: () => bgBlue,
        bgCyan: () => bgCyan,
        bgGreen: () => bgGreen,
        bgMagenta: () => bgMagenta,
        bgRed: () => bgRed,
        bgWhite: () => bgWhite,
        bgYellow: () => bgYellow,
        black: () => black,
        blue: () => blue,
        bold: () => bold,
        cyan: () => cyan,
        dim: () => dim,
        gray: () => gray,
        green: () => green,
        grey: () => grey,
        hidden: () => hidden,
        inverse: () => inverse,
        italic: () => italic,
        magenta: () => magenta,
        red: () => red,
        reset: () => reset,
        strikethrough: () => strikethrough,
        underline: () => underline,
        white: () => white,
        yellow: () => yellow
      });
      var FORCE_COLOR;
      var NODE_DISABLE_COLORS;
      var NO_COLOR;
      var TERM;
      var isTTY = true;
      if (typeof process !== "undefined") {
        ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
        isTTY = process.stdout && process.stdout.isTTY;
      }
      var $ = {
        enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
      };
      function init(x, y) {
        let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
        let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
        return function(txt) {
          if (!$.enabled || txt == null) return txt;
          return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
        };
      }
      var reset = init(0, 0);
      var bold = init(1, 22);
      var dim = init(2, 22);
      var italic = init(3, 23);
      var underline = init(4, 24);
      var inverse = init(7, 27);
      var hidden = init(8, 28);
      var strikethrough = init(9, 29);
      var black = init(30, 39);
      var red = init(31, 39);
      var green = init(32, 39);
      var yellow = init(33, 39);
      var blue = init(34, 39);
      var magenta = init(35, 39);
      var cyan = init(36, 39);
      var white = init(37, 39);
      var gray = init(90, 39);
      var grey = init(90, 39);
      var bgBlack = init(40, 49);
      var bgRed = init(41, 49);
      var bgGreen = init(42, 49);
      var bgYellow = init(43, 49);
      var bgBlue = init(44, 49);
      var bgMagenta = init(45, 49);
      var bgCyan = init(46, 49);
      var bgWhite = init(47, 49);
      var MAX_ARGS_HISTORY = 100;
      var COLORS = ["green", "yellow", "blue", "magenta", "cyan", "red"];
      var argsHistory = [];
      var lastTimestamp = Date.now();
      var lastColor = 0;
      var processEnv = typeof process !== "undefined" ? process.env : {};
      globalThis.DEBUG ??= processEnv.DEBUG ?? "";
      globalThis.DEBUG_COLORS ??= processEnv.DEBUG_COLORS ? processEnv.DEBUG_COLORS === "true" : true;
      var topProps = {
        enable(namespace) {
          if (typeof namespace === "string") {
            globalThis.DEBUG = namespace;
          }
        },
        disable() {
          const prev = globalThis.DEBUG;
          globalThis.DEBUG = "";
          return prev;
        },
        // this is the core logic to check if logging should happen or not
        enabled(namespace) {
          const listenedNamespaces = globalThis.DEBUG.split(",").map((s) => {
            return s.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
          });
          const isListened = listenedNamespaces.some((listenedNamespace) => {
            if (listenedNamespace === "" || listenedNamespace[0] === "-") return false;
            return namespace.match(RegExp(listenedNamespace.split("*").join(".*") + "$"));
          });
          const isExcluded = listenedNamespaces.some((listenedNamespace) => {
            if (listenedNamespace === "" || listenedNamespace[0] !== "-") return false;
            return namespace.match(RegExp(listenedNamespace.slice(1).split("*").join(".*") + "$"));
          });
          return isListened && !isExcluded;
        },
        log: (...args) => {
          const [namespace, format, ...rest] = args;
          const logWithFormatting = console.warn ?? console.log;
          logWithFormatting(`${namespace} ${format}`, ...rest);
        },
        formatters: {}
        // not implemented
      };
      function debugCreate(namespace) {
        const instanceProps = {
          color: COLORS[lastColor++ % COLORS.length],
          enabled: topProps.enabled(namespace),
          namespace,
          log: topProps.log,
          extend: () => {
          }
          // not implemented
        };
        const debugCall = (...args) => {
          const { enabled, namespace: namespace2, color, log } = instanceProps;
          if (args.length !== 0) {
            argsHistory.push([namespace2, ...args]);
          }
          if (argsHistory.length > MAX_ARGS_HISTORY) {
            argsHistory.shift();
          }
          if (topProps.enabled(namespace2) || enabled) {
            const stringArgs = args.map((arg) => {
              if (typeof arg === "string") {
                return arg;
              }
              return safeStringify(arg);
            });
            const ms = `+${Date.now() - lastTimestamp}ms`;
            lastTimestamp = Date.now();
            if (globalThis.DEBUG_COLORS) {
              log(colors_exports[color](bold(namespace2)), ...stringArgs, colors_exports[color](ms));
            } else {
              log(namespace2, ...stringArgs, ms);
            }
          }
        };
        return new Proxy(debugCall, {
          get: (_, prop) => instanceProps[prop],
          set: (_, prop, value) => instanceProps[prop] = value
        });
      }
      var Debug = new Proxy(debugCreate, {
        get: (_, prop) => topProps[prop],
        set: (_, prop, value) => topProps[prop] = value
      });
      function safeStringify(value, indent = 2) {
        const cache = /* @__PURE__ */ new Set();
        return JSON.stringify(
          value,
          (key, value2) => {
            if (typeof value2 === "object" && value2 !== null) {
              if (cache.has(value2)) {
                return `[Circular *]`;
              }
              cache.add(value2);
            } else if (typeof value2 === "bigint") {
              return value2.toString();
            }
            return value2;
          },
          indent
        );
      }
      function getLogs(numChars = 7500) {
        const logs = argsHistory.map(([namespace, ...args]) => {
          return `${namespace} ${args.map((arg) => {
            if (typeof arg === "string") {
              return arg;
            } else {
              return JSON.stringify(arg);
            }
          }).join(" ")}`;
        }).join("\n");
        if (logs.length < numChars) {
          return logs;
        }
        return logs.slice(-numChars);
      }
      function clearLogs() {
        argsHistory.length = 0;
      }
      var src_default = Debug;
    }
  });

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-YCVAQFCS.js
  var require_chunk_YCVAQFCS = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-YCVAQFCS.js"(exports, module) {
      "use strict";
      var __create2 = Object.create;
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __getProtoOf2 = Object.getPrototypeOf;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
        // If the importer is in node compatibility mode or this is not an ESM
        // file that has been converted to a CommonJS file using a Babel-
        // compatible transform (i.e. "__esModule" has not been set), then set
        // "default" to the CommonJS "module.exports" for node compatibility.
        isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
        mod
      ));
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var chunk_YCVAQFCS_exports = {};
      __export(chunk_YCVAQFCS_exports, {
        GeneratorError: () => GeneratorError,
        GeneratorProcess: () => GeneratorProcess
      });
      module.exports = __toCommonJS(chunk_YCVAQFCS_exports);
      var import_chunk_EOPVK4AE = require_chunk_EOPVK4AE();
      var import_chunk_QGM4M3NI = require_chunk_QGM4M3NI();
      var import_debug = __toESM2(require_dist());
      var import_child_process = __require("child_process");
      var require_windows = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
          "use strict";
          module2.exports = isexe;
          isexe.sync = sync;
          var fs2 = (0, import_chunk_QGM4M3NI.__require)("fs");
          function checkPathExt(path2, options) {
            var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
            if (!pathext) {
              return true;
            }
            pathext = pathext.split(";");
            if (pathext.indexOf("") !== -1) {
              return true;
            }
            for (var i = 0; i < pathext.length; i++) {
              var p = pathext[i].toLowerCase();
              if (p && path2.substr(-p.length).toLowerCase() === p) {
                return true;
              }
            }
            return false;
          }
          function checkStat(stat, path2, options) {
            if (!stat.isSymbolicLink() && !stat.isFile()) {
              return false;
            }
            return checkPathExt(path2, options);
          }
          function isexe(path2, options, cb) {
            fs2.stat(path2, function(er, stat) {
              cb(er, er ? false : checkStat(stat, path2, options));
            });
          }
          function sync(path2, options) {
            return checkStat(fs2.statSync(path2), path2, options);
          }
        }
      });
      var require_mode = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
          "use strict";
          module2.exports = isexe;
          isexe.sync = sync;
          var fs2 = (0, import_chunk_QGM4M3NI.__require)("fs");
          function isexe(path2, options, cb) {
            fs2.stat(path2, function(er, stat) {
              cb(er, er ? false : checkStat(stat, options));
            });
          }
          function sync(path2, options) {
            return checkStat(fs2.statSync(path2), options);
          }
          function checkStat(stat, options) {
            return stat.isFile() && checkMode(stat, options);
          }
          function checkMode(stat, options) {
            var mod = stat.mode;
            var uid = stat.uid;
            var gid = stat.gid;
            var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
            var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
            var u = parseInt("100", 8);
            var g = parseInt("010", 8);
            var o = parseInt("001", 8);
            var ug = u | g;
            var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
            return ret;
          }
        }
      });
      var require_isexe = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
          "use strict";
          var fs2 = (0, import_chunk_QGM4M3NI.__require)("fs");
          var core;
          if (process.platform === "win32" || global.TESTING_WINDOWS) {
            core = require_windows();
          } else {
            core = require_mode();
          }
          module2.exports = isexe;
          isexe.sync = sync;
          function isexe(path2, options, cb) {
            if (typeof options === "function") {
              cb = options;
              options = {};
            }
            if (!cb) {
              if (typeof Promise !== "function") {
                throw new TypeError("callback not provided");
              }
              return new Promise(function(resolve2, reject) {
                isexe(path2, options || {}, function(er, is) {
                  if (er) {
                    reject(er);
                  } else {
                    resolve2(is);
                  }
                });
              });
            }
            core(path2, options || {}, function(er, is) {
              if (er) {
                if (er.code === "EACCES" || options && options.ignoreErrors) {
                  er = null;
                  is = false;
                }
              }
              cb(er, is);
            });
          }
          function sync(path2, options) {
            try {
              return core.sync(path2, options || {});
            } catch (er) {
              if (options && options.ignoreErrors || er.code === "EACCES") {
                return false;
              } else {
                throw er;
              }
            }
          }
        }
      });
      var require_which = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports2, module2) {
          "use strict";
          var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
          var path2 = (0, import_chunk_QGM4M3NI.__require)("path");
          var COLON = isWindows ? ";" : ":";
          var isexe = require_isexe();
          var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
          var getPathInfo = (cmd, opt) => {
            const colon = opt.colon || COLON;
            const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
              // windows always checks the cwd first
              ...isWindows ? [process.cwd()] : [],
              ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
              "").split(colon)
            ];
            const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
            const pathExt = isWindows ? pathExtExe.split(colon) : [""];
            if (isWindows) {
              if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
                pathExt.unshift("");
            }
            return {
              pathEnv,
              pathExt,
              pathExtExe
            };
          };
          var which = (cmd, opt, cb) => {
            if (typeof opt === "function") {
              cb = opt;
              opt = {};
            }
            if (!opt)
              opt = {};
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            const step = (i) => new Promise((resolve2, reject) => {
              if (i === pathEnv.length)
                return opt.all && found.length ? resolve2(found) : reject(getNotFoundError(cmd));
              const ppRaw = pathEnv[i];
              const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
              const pCmd = path2.join(pathPart, cmd);
              const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
              resolve2(subStep(p, i, 0));
            });
            const subStep = (p, i, ii) => new Promise((resolve2, reject) => {
              if (ii === pathExt.length)
                return resolve2(step(i + 1));
              const ext = pathExt[ii];
              isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
                if (!er && is) {
                  if (opt.all)
                    found.push(p + ext);
                  else
                    return resolve2(p + ext);
                }
                return resolve2(subStep(p, i, ii + 1));
              });
            });
            return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
          };
          var whichSync = (cmd, opt) => {
            opt = opt || {};
            const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
            const found = [];
            for (let i = 0; i < pathEnv.length; i++) {
              const ppRaw = pathEnv[i];
              const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
              const pCmd = path2.join(pathPart, cmd);
              const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
              for (let j = 0; j < pathExt.length; j++) {
                const cur = p + pathExt[j];
                try {
                  const is = isexe.sync(cur, { pathExt: pathExtExe });
                  if (is) {
                    if (opt.all)
                      found.push(cur);
                    else
                      return cur;
                  }
                } catch (ex) {
                }
              }
            }
            if (opt.all && found.length)
              return found;
            if (opt.nothrow)
              return null;
            throw getNotFoundError(cmd);
          };
          module2.exports = which;
          which.sync = whichSync;
        }
      });
      var require_path_key = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports2, module2) {
          "use strict";
          var pathKey = (options = {}) => {
            const environment = options.env || process.env;
            const platform = options.platform || process.platform;
            if (platform !== "win32") {
              return "PATH";
            }
            return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
          };
          module2.exports = pathKey;
          module2.exports.default = pathKey;
        }
      });
      var require_resolveCommand = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
          "use strict";
          var path2 = (0, import_chunk_QGM4M3NI.__require)("path");
          var which = require_which();
          var getPathKey = require_path_key();
          function resolveCommandAttempt(parsed, withoutPathExt) {
            const env = parsed.options.env || process.env;
            const cwd = process.cwd();
            const hasCustomCwd = parsed.options.cwd != null;
            const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
            if (shouldSwitchCwd) {
              try {
                process.chdir(parsed.options.cwd);
              } catch (err) {
              }
            }
            let resolved;
            try {
              resolved = which.sync(parsed.command, {
                path: env[getPathKey({ env })],
                pathExt: withoutPathExt ? path2.delimiter : void 0
              });
            } catch (e) {
            } finally {
              if (shouldSwitchCwd) {
                process.chdir(cwd);
              }
            }
            if (resolved) {
              resolved = path2.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
            }
            return resolved;
          }
          function resolveCommand(parsed) {
            return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
          }
          module2.exports = resolveCommand;
        }
      });
      var require_escape = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
          "use strict";
          var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
          function escapeCommand(arg) {
            arg = arg.replace(metaCharsRegExp, "^$1");
            return arg;
          }
          function escapeArgument(arg, doubleEscapeMetaChars) {
            arg = `${arg}`;
            arg = arg.replace(/(?=(\\+?)?)\1"/g, '$1$1\\"');
            arg = arg.replace(/(?=(\\+?)?)\1$/, "$1$1");
            arg = `"${arg}"`;
            arg = arg.replace(metaCharsRegExp, "^$1");
            if (doubleEscapeMetaChars) {
              arg = arg.replace(metaCharsRegExp, "^$1");
            }
            return arg;
          }
          module2.exports.command = escapeCommand;
          module2.exports.argument = escapeArgument;
        }
      });
      var require_shebang_regex = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
          "use strict";
          module2.exports = /^#!(.*)/;
        }
      });
      var require_shebang_command = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports2, module2) {
          "use strict";
          var shebangRegex = require_shebang_regex();
          module2.exports = (string = "") => {
            const match = string.match(shebangRegex);
            if (!match) {
              return null;
            }
            const [path2, argument] = match[0].replace(/#! ?/, "").split(" ");
            const binary = path2.split("/").pop();
            if (binary === "env") {
              return argument;
            }
            return argument ? `${binary} ${argument}` : binary;
          };
        }
      });
      var require_readShebang = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
          "use strict";
          var fs2 = (0, import_chunk_QGM4M3NI.__require)("fs");
          var shebangCommand = require_shebang_command();
          function readShebang(command) {
            const size = 150;
            const buffer = Buffer.alloc(size);
            let fd;
            try {
              fd = fs2.openSync(command, "r");
              fs2.readSync(fd, buffer, 0, size, 0);
              fs2.closeSync(fd);
            } catch (e) {
            }
            return shebangCommand(buffer.toString());
          }
          module2.exports = readShebang;
        }
      });
      var require_parse = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
          "use strict";
          var path2 = (0, import_chunk_QGM4M3NI.__require)("path");
          var resolveCommand = require_resolveCommand();
          var escape = require_escape();
          var readShebang = require_readShebang();
          var isWin = process.platform === "win32";
          var isExecutableRegExp = /\.(?:com|exe)$/i;
          var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
          function detectShebang(parsed) {
            parsed.file = resolveCommand(parsed);
            const shebang = parsed.file && readShebang(parsed.file);
            if (shebang) {
              parsed.args.unshift(parsed.file);
              parsed.command = shebang;
              return resolveCommand(parsed);
            }
            return parsed.file;
          }
          function parseNonShell(parsed) {
            if (!isWin) {
              return parsed;
            }
            const commandFile = detectShebang(parsed);
            const needsShell = !isExecutableRegExp.test(commandFile);
            if (parsed.options.forceShell || needsShell) {
              const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
              parsed.command = path2.normalize(parsed.command);
              parsed.command = escape.command(parsed.command);
              parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
              const shellCommand = [parsed.command].concat(parsed.args).join(" ");
              parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
              parsed.command = process.env.comspec || "cmd.exe";
              parsed.options.windowsVerbatimArguments = true;
            }
            return parsed;
          }
          function parse(command, args, options) {
            if (args && !Array.isArray(args)) {
              options = args;
              args = null;
            }
            args = args ? args.slice(0) : [];
            options = Object.assign({}, options);
            const parsed = {
              command,
              args,
              options,
              file: void 0,
              original: {
                command,
                args
              }
            };
            return options.shell ? parsed : parseNonShell(parsed);
          }
          module2.exports = parse;
        }
      });
      var require_enoent = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
          "use strict";
          var isWin = process.platform === "win32";
          function notFoundError(original, syscall) {
            return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
              code: "ENOENT",
              errno: "ENOENT",
              syscall: `${syscall} ${original.command}`,
              path: original.command,
              spawnargs: original.args
            });
          }
          function hookChildProcess(cp, parsed) {
            if (!isWin) {
              return;
            }
            const originalEmit = cp.emit;
            cp.emit = function(name, arg1) {
              if (name === "exit") {
                const err = verifyENOENT(arg1, parsed);
                if (err) {
                  return originalEmit.call(cp, "error", err);
                }
              }
              return originalEmit.apply(cp, arguments);
            };
          }
          function verifyENOENT(status, parsed) {
            if (isWin && status === 1 && !parsed.file) {
              return notFoundError(parsed.original, "spawn");
            }
            return null;
          }
          function verifyENOENTSync(status, parsed) {
            if (isWin && status === 1 && !parsed.file) {
              return notFoundError(parsed.original, "spawnSync");
            }
            return null;
          }
          module2.exports = {
            hookChildProcess,
            verifyENOENT,
            verifyENOENTSync,
            notFoundError
          };
        }
      });
      var require_cross_spawn = (0, import_chunk_QGM4M3NI.__commonJS)({
        "../../node_modules/.pnpm/cross-spawn@7.0.6/node_modules/cross-spawn/index.js"(exports2, module2) {
          "use strict";
          var cp = (0, import_chunk_QGM4M3NI.__require)("child_process");
          var parse = require_parse();
          var enoent = require_enoent();
          function spawn2(command, args, options) {
            const parsed = parse(command, args, options);
            const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
            enoent.hookChildProcess(spawned, parsed);
            return spawned;
          }
          function spawnSync(command, args, options) {
            const parsed = parse(command, args, options);
            const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
            result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
            return result;
          }
          module2.exports = spawn2;
          module2.exports.spawn = spawn2;
          module2.exports.sync = spawnSync;
          module2.exports._parse = parse;
          module2.exports._enoent = enoent;
        }
      });
      var import_cross_spawn = (0, import_chunk_QGM4M3NI.__toESM)(require_cross_spawn());
      var FORCE_COLOR;
      var NODE_DISABLE_COLORS;
      var NO_COLOR;
      var TERM;
      var isTTY = true;
      if (typeof process !== "undefined") {
        ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
        isTTY = process.stdout && process.stdout.isTTY;
      }
      var $ = {
        enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
      };
      function init(x, y) {
        let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
        let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
        return function(txt) {
          if (!$.enabled || txt == null) return txt;
          return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
        };
      }
      var reset = init(0, 0);
      var bold = init(1, 22);
      var dim = init(2, 22);
      var italic = init(3, 23);
      var underline = init(4, 24);
      var inverse = init(7, 27);
      var hidden = init(8, 28);
      var strikethrough = init(9, 29);
      var black = init(30, 39);
      var red = init(31, 39);
      var green = init(32, 39);
      var yellow = init(33, 39);
      var blue = init(34, 39);
      var magenta = init(35, 39);
      var cyan = init(36, 39);
      var white = init(37, 39);
      var gray = init(90, 39);
      var grey = init(90, 39);
      var bgBlack = init(40, 49);
      var bgRed = init(41, 49);
      var bgGreen = init(42, 49);
      var bgYellow = init(43, 49);
      var bgBlue = init(44, 49);
      var bgMagenta = init(45, 49);
      var bgCyan = init(46, 49);
      var bgWhite = init(47, 49);
      var debug = (0, import_debug.default)("prisma:GeneratorProcess");
      var globalMessageId = 1;
      var GeneratorError = class extends Error {
        constructor(message, code, data) {
          super(message);
          this.code = code;
          this.data = data;
          this.name = "GeneratorError";
          if (data?.stack) {
            this.stack = data.stack;
          }
        }
      };
      var GeneratorProcess = class {
        constructor(pathOrCommand, { isNode = false } = {}) {
          this.pathOrCommand = pathOrCommand;
          this.handlers = {};
          this.errorLogs = "";
          this.exited = false;
          this.getManifest = this.rpcMethod(
            "getManifest",
            (result) => result.manifest ?? null
          );
          this.generate = this.rpcMethod("generate");
          this.isNode = isNode;
        }
        async init() {
          if (!this.initPromise) {
            this.initPromise = this.initSingleton();
          }
          return this.initPromise;
        }
        initSingleton() {
          return new Promise((resolve2, reject) => {
            if (this.isNode) {
              this.child = (0, import_child_process.fork)(this.pathOrCommand, [], {
                stdio: ["pipe", "inherit", "pipe", "ipc"],
                env: {
                  ...process.env,
                  PRISMA_GENERATOR_INVOCATION: "true"
                },
                // TODO: this assumes the host has at least 8 GB of RAM which may not be the case.
                execArgv: ["--max-old-space-size=8096"]
              });
            } else {
              this.child = (0, import_cross_spawn.spawn)(this.pathOrCommand, {
                stdio: ["pipe", "inherit", "pipe"],
                env: {
                  ...process.env,
                  PRISMA_GENERATOR_INVOCATION: "true"
                },
                shell: true
              });
            }
            this.child.on("exit", (code, signal) => {
              debug(`child exited with code ${code} on signal ${signal}`);
              this.exited = true;
              if (code) {
                const error = new GeneratorError(
                  `Generator ${JSON.stringify(this.pathOrCommand)} failed:

${this.errorLogs}`
                );
                this.pendingError = error;
                this.rejectAllHandlers(error);
              }
            });
            this.child.stdin.on("error", () => {
            });
            this.child.on("error", (error) => {
              debug(error);
              this.pendingError = error;
              if (error.code === "EACCES") {
                reject(
                  new Error(
                    `The executable at ${this.pathOrCommand} lacks the right permissions. Please use ${bold(
                      `chmod +x ${this.pathOrCommand}`
                    )}`
                  )
                );
              } else {
                reject(error);
              }
              this.rejectAllHandlers(error);
            });
            (0, import_chunk_EOPVK4AE.byline)(this.child.stderr).on("data", (line) => {
              const response = String(line);
              let data;
              try {
                data = JSON.parse(response);
              } catch (e) {
                this.errorLogs += response + "\n";
                debug(response);
              }
              if (data) {
                this.handleResponse(data);
              }
            });
            this.child.on("spawn", resolve2);
          });
        }
        rejectAllHandlers(error) {
          for (const id of Object.keys(this.handlers)) {
            this.handlers[id].reject(error);
            delete this.handlers[id];
          }
        }
        handleResponse(data) {
          if (data.jsonrpc && data.id) {
            if (typeof data.id !== "number") {
              throw new Error(`message.id has to be a number. Found value ${data.id}`);
            }
            if (this.handlers[data.id]) {
              if (isErrorResponse(data)) {
                const error = new GeneratorError(data.error.message, data.error.code, data.error.data);
                this.handlers[data.id].reject(error);
              } else {
                this.handlers[data.id].resolve(data.result);
              }
              delete this.handlers[data.id];
            }
          }
        }
        sendMessage(message, callback) {
          if (!this.child) {
            callback(new GeneratorError("Generator process has not started yet"));
            return;
          }
          if (!this.child.stdin.writable) {
            callback(new GeneratorError("Cannot send data to the generator process, process already exited"));
            return;
          }
          this.child.stdin.write(JSON.stringify(message) + "\n", (error) => {
            if (!error) {
              return callback();
            }
            if (error.code === "EPIPE") {
              return callback();
            }
            callback(error);
          });
        }
        getMessageId() {
          return globalMessageId++;
        }
        stop() {
          if (this.child && !this.child?.killed) {
            this.child.kill("SIGTERM");
            const timeoutMs = 2e3;
            const intervalMs = 200;
            let interval;
            let timeout;
            Promise.race([
              new Promise((resolve2) => {
                timeout = setTimeout(resolve2, timeoutMs);
              }),
              new Promise((resolve2) => {
                interval = setInterval(() => {
                  if (this.exited) {
                    return resolve2("exited");
                  }
                }, intervalMs);
              })
            ]).then((result) => {
              if (result !== "exited") {
                this.child?.kill("SIGKILL");
              }
            }).finally(() => {
              clearInterval(interval);
              clearTimeout(timeout);
            });
          }
        }
        rpcMethod(method, mapResult = (x) => x) {
          return (params) => new Promise((resolve2, reject) => {
            if (this.pendingError) {
              reject(this.pendingError);
              return;
            }
            const messageId = this.getMessageId();
            this.handlers[messageId] = {
              resolve: (result) => resolve2(mapResult(result)),
              reject
            };
            this.sendMessage(
              {
                jsonrpc: "2.0",
                method,
                params,
                id: messageId
              },
              (error) => {
                if (error) reject(error);
              }
            );
          });
        }
      };
      function isErrorResponse(response) {
        return response.error !== void 0;
      }
    }
  });

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-JU65QD3H.js
  var require_chunk_JU65QD3H = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-JU65QD3H.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var chunk_JU65QD3H_exports = {};
      __export(chunk_JU65QD3H_exports, {
        DMMF: () => DMMF,
        datamodelEnumToSchemaEnum: () => datamodelEnumToSchemaEnum
      });
      module.exports = __toCommonJS(chunk_JU65QD3H_exports);
      function datamodelEnumToSchemaEnum(datamodelEnum) {
        return {
          name: datamodelEnum.name,
          values: datamodelEnum.values.map((v) => v.name)
        };
      }
      var DMMF;
      ((DMMF2) => {
        let ModelAction;
        ((ModelAction2) => {
          ModelAction2["findUnique"] = "findUnique";
          ModelAction2["findUniqueOrThrow"] = "findUniqueOrThrow";
          ModelAction2["findFirst"] = "findFirst";
          ModelAction2["findFirstOrThrow"] = "findFirstOrThrow";
          ModelAction2["findMany"] = "findMany";
          ModelAction2["create"] = "create";
          ModelAction2["createMany"] = "createMany";
          ModelAction2["createManyAndReturn"] = "createManyAndReturn";
          ModelAction2["update"] = "update";
          ModelAction2["updateMany"] = "updateMany";
          ModelAction2["updateManyAndReturn"] = "updateManyAndReturn";
          ModelAction2["upsert"] = "upsert";
          ModelAction2["delete"] = "delete";
          ModelAction2["deleteMany"] = "deleteMany";
          ModelAction2["groupBy"] = "groupBy";
          ModelAction2["count"] = "count";
          ModelAction2["aggregate"] = "aggregate";
          ModelAction2["findRaw"] = "findRaw";
          ModelAction2["aggregateRaw"] = "aggregateRaw";
        })(ModelAction = DMMF2.ModelAction || (DMMF2.ModelAction = {}));
      })(DMMF || (DMMF = {}));
    }
  });

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-NAG6CCUN.js
  var require_chunk_NAG6CCUN = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-NAG6CCUN.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var chunk_NAG6CCUN_exports = {};
      __export(chunk_NAG6CCUN_exports, {
        generatorHandler: () => generatorHandler2
      });
      module.exports = __toCommonJS(chunk_NAG6CCUN_exports);
      var import_chunk_EOPVK4AE = require_chunk_EOPVK4AE();
      function generatorHandler2(handler) {
        (0, import_chunk_EOPVK4AE.byline)(process.stdin).on("data", async (line) => {
          const json = JSON.parse(String(line));
          if (json.method === "generate" && json.params) {
            try {
              const result = await handler.onGenerate(json.params);
              respond({
                jsonrpc: "2.0",
                result,
                id: json.id
              });
            } catch (_e) {
              const e = _e;
              respond({
                jsonrpc: "2.0",
                error: {
                  code: -32e3,
                  message: e.message,
                  data: {
                    stack: e.stack
                  }
                },
                id: json.id
              });
            }
          }
          if (json.method === "getManifest") {
            if (handler.onManifest) {
              try {
                const manifest = handler.onManifest(json.params);
                respond({
                  jsonrpc: "2.0",
                  result: {
                    manifest
                  },
                  id: json.id
                });
              } catch (_e) {
                const e = _e;
                respond({
                  jsonrpc: "2.0",
                  error: {
                    code: -32e3,
                    message: e.message,
                    data: {
                      stack: e.stack
                    }
                  },
                  id: json.id
                });
              }
            } else {
              respond({
                jsonrpc: "2.0",
                result: {
                  manifest: null
                },
                id: json.id
              });
            }
          }
        });
        process.stdin.resume();
      }
      function respond(response) {
        console.error(JSON.stringify(response));
      }
    }
  });

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-6F4PWJZI.js
  var require_chunk_6F4PWJZI = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/chunk-6F4PWJZI.js"() {
      "use strict";
    }
  });

  // node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/.pnpm/@prisma+generator-helper@6.2.1/node_modules/@prisma/generator-helper/dist/index.js"(exports, module) {
      "use strict";
      var __defProp2 = Object.defineProperty;
      var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames2 = Object.getOwnPropertyNames;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps2 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames2(from))
            if (!__hasOwnProp2.call(to, key) && key !== except)
              __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
      var dist_exports = {};
      __export(dist_exports, {
        DMMF: () => import_chunk_JU65QD3H.DMMF,
        GeneratorError: () => import_chunk_YCVAQFCS.GeneratorError,
        GeneratorProcess: () => import_chunk_YCVAQFCS.GeneratorProcess,
        datamodelEnumToSchemaEnum: () => import_chunk_JU65QD3H.datamodelEnumToSchemaEnum,
        generatorHandler: () => import_chunk_NAG6CCUN.generatorHandler
      });
      module.exports = __toCommonJS(dist_exports);
      var import_chunk_YCVAQFCS = require_chunk_YCVAQFCS();
      var import_chunk_JU65QD3H = require_chunk_JU65QD3H();
      var import_chunk_NAG6CCUN = require_chunk_NAG6CCUN();
      var import_chunk_EOPVK4AE = require_chunk_EOPVK4AE();
      var import_chunk_QGM4M3NI = require_chunk_QGM4M3NI();
      var import_chunk_6F4PWJZI = require_chunk_6F4PWJZI();
    }
  });

  // node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/package.json
  var require_package = __commonJS({
    "node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/package.json"(exports, module) {
      module.exports = {
        name: "dotenv",
        version: "16.4.7",
        description: "Loads environment variables from .env file",
        main: "lib/main.js",
        types: "lib/main.d.ts",
        exports: {
          ".": {
            types: "./lib/main.d.ts",
            require: "./lib/main.js",
            default: "./lib/main.js"
          },
          "./config": "./config.js",
          "./config.js": "./config.js",
          "./lib/env-options": "./lib/env-options.js",
          "./lib/env-options.js": "./lib/env-options.js",
          "./lib/cli-options": "./lib/cli-options.js",
          "./lib/cli-options.js": "./lib/cli-options.js",
          "./package.json": "./package.json"
        },
        scripts: {
          "dts-check": "tsc --project tests/types/tsconfig.json",
          lint: "standard",
          pretest: "npm run lint && npm run dts-check",
          test: "tap run --allow-empty-coverage --disable-coverage --timeout=60000",
          "test:coverage": "tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",
          prerelease: "npm test",
          release: "standard-version"
        },
        repository: {
          type: "git",
          url: "git://github.com/motdotla/dotenv.git"
        },
        funding: "https://dotenvx.com",
        keywords: [
          "dotenv",
          "env",
          ".env",
          "environment",
          "variables",
          "config",
          "settings"
        ],
        readmeFilename: "README.md",
        license: "BSD-2-Clause",
        devDependencies: {
          "@types/node": "^18.11.3",
          decache: "^4.6.2",
          sinon: "^14.0.1",
          standard: "^17.0.0",
          "standard-version": "^9.5.0",
          tap: "^19.2.0",
          typescript: "^4.8.4"
        },
        engines: {
          node: ">=12"
        },
        browser: {
          fs: false
        }
      };
    }
  });

  // node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/lib/main.js
  var require_main = __commonJS({
    "node_modules/.pnpm/dotenv@16.4.7/node_modules/dotenv/lib/main.js"(exports, module) {
      "use strict";
      var fs2 = __require("fs");
      var path2 = __require("path");
      var os2 = __require("os");
      var crypto = __require("crypto");
      var packageJson = require_package();
      var version = packageJson.version;
      var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
      function parse(src) {
        const obj = {};
        let lines = src.toString();
        lines = lines.replace(/\r\n?/mg, "\n");
        let match;
        while ((match = LINE.exec(lines)) != null) {
          const key = match[1];
          let value = match[2] || "";
          value = value.trim();
          const maybeQuote = value[0];
          value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
          if (maybeQuote === '"') {
            value = value.replace(/\\n/g, "\n");
            value = value.replace(/\\r/g, "\r");
          }
          obj[key] = value;
        }
        return obj;
      }
      function _parseVault(options) {
        const vaultPath = _vaultPath(options);
        const result = DotenvModule.configDotenv({ path: vaultPath });
        if (!result.parsed) {
          const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
          err.code = "MISSING_DATA";
          throw err;
        }
        const keys = _dotenvKey(options).split(",");
        const length = keys.length;
        let decrypted;
        for (let i = 0; i < length; i++) {
          try {
            const key = keys[i].trim();
            const attrs = _instructions(result, key);
            decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
            break;
          } catch (error) {
            if (i + 1 >= length) {
              throw error;
            }
          }
        }
        return DotenvModule.parse(decrypted);
      }
      function _log(message) {
        console.log(`[dotenv@${version}][INFO] ${message}`);
      }
      function _warn(message) {
        console.log(`[dotenv@${version}][WARN] ${message}`);
      }
      function _debug(message) {
        console.log(`[dotenv@${version}][DEBUG] ${message}`);
      }
      function _dotenvKey(options) {
        if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
          return options.DOTENV_KEY;
        }
        if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
          return process.env.DOTENV_KEY;
        }
        return "";
      }
      function _instructions(result, dotenvKey) {
        let uri;
        try {
          uri = new URL(dotenvKey);
        } catch (error) {
          if (error.code === "ERR_INVALID_URL") {
            const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
            err.code = "INVALID_DOTENV_KEY";
            throw err;
          }
          throw error;
        }
        const key = uri.password;
        if (!key) {
          const err = new Error("INVALID_DOTENV_KEY: Missing key part");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        const environment = uri.searchParams.get("environment");
        if (!environment) {
          const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
        const ciphertext = result.parsed[environmentKey];
        if (!ciphertext) {
          const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
          err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
          throw err;
        }
        return { ciphertext, key };
      }
      function _vaultPath(options) {
        let possibleVaultPath = null;
        if (options && options.path && options.path.length > 0) {
          if (Array.isArray(options.path)) {
            for (const filepath of options.path) {
              if (fs2.existsSync(filepath)) {
                possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
              }
            }
          } else {
            possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
          }
        } else {
          possibleVaultPath = path2.resolve(process.cwd(), ".env.vault");
        }
        if (fs2.existsSync(possibleVaultPath)) {
          return possibleVaultPath;
        }
        return null;
      }
      function _resolveHome(envPath) {
        return envPath[0] === "~" ? path2.join(os2.homedir(), envPath.slice(1)) : envPath;
      }
      function _configVault(options) {
        _log("Loading env from encrypted .env.vault");
        const parsed = DotenvModule._parseVault(options);
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsed, options);
        return { parsed };
      }
      function configDotenv(options) {
        const dotenvPath = path2.resolve(process.cwd(), ".env");
        let encoding = "utf8";
        const debug = Boolean(options && options.debug);
        if (options && options.encoding) {
          encoding = options.encoding;
        } else {
          if (debug) {
            _debug("No encoding is specified. UTF-8 is used by default");
          }
        }
        let optionPaths = [dotenvPath];
        if (options && options.path) {
          if (!Array.isArray(options.path)) {
            optionPaths = [_resolveHome(options.path)];
          } else {
            optionPaths = [];
            for (const filepath of options.path) {
              optionPaths.push(_resolveHome(filepath));
            }
          }
        }
        let lastError;
        const parsedAll = {};
        for (const path3 of optionPaths) {
          try {
            const parsed = DotenvModule.parse(fs2.readFileSync(path3, { encoding }));
            DotenvModule.populate(parsedAll, parsed, options);
          } catch (e) {
            if (debug) {
              _debug(`Failed to load ${path3} ${e.message}`);
            }
            lastError = e;
          }
        }
        let processEnv = process.env;
        if (options && options.processEnv != null) {
          processEnv = options.processEnv;
        }
        DotenvModule.populate(processEnv, parsedAll, options);
        if (lastError) {
          return { parsed: parsedAll, error: lastError };
        } else {
          return { parsed: parsedAll };
        }
      }
      function config2(options) {
        if (_dotenvKey(options).length === 0) {
          return DotenvModule.configDotenv(options);
        }
        const vaultPath = _vaultPath(options);
        if (!vaultPath) {
          _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
          return DotenvModule.configDotenv(options);
        }
        return DotenvModule._configVault(options);
      }
      function decrypt(encrypted, keyStr) {
        const key = Buffer.from(keyStr.slice(-64), "hex");
        let ciphertext = Buffer.from(encrypted, "base64");
        const nonce = ciphertext.subarray(0, 12);
        const authTag = ciphertext.subarray(-16);
        ciphertext = ciphertext.subarray(12, -16);
        try {
          const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
          aesgcm.setAuthTag(authTag);
          return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
        } catch (error) {
          const isRange = error instanceof RangeError;
          const invalidKeyLength = error.message === "Invalid key length";
          const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
          if (isRange || invalidKeyLength) {
            const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
            err.code = "INVALID_DOTENV_KEY";
            throw err;
          } else if (decryptionFailed) {
            const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
            err.code = "DECRYPTION_FAILED";
            throw err;
          } else {
            throw error;
          }
        }
      }
      function populate(processEnv, parsed, options = {}) {
        const debug = Boolean(options && options.debug);
        const override = Boolean(options && options.override);
        if (typeof parsed !== "object") {
          const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
          err.code = "OBJECT_REQUIRED";
          throw err;
        }
        for (const key of Object.keys(parsed)) {
          if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
            if (override === true) {
              processEnv[key] = parsed[key];
            }
            if (debug) {
              if (override === true) {
                _debug(`"${key}" is already defined and WAS overwritten`);
              } else {
                _debug(`"${key}" is already defined and was NOT overwritten`);
              }
            }
          } else {
            processEnv[key] = parsed[key];
          }
        }
      }
      var DotenvModule = {
        configDotenv,
        _configVault,
        _parseVault,
        config: config2,
        decrypt,
        parse,
        populate
      };
      module.exports.configDotenv = DotenvModule.configDotenv;
      module.exports._configVault = DotenvModule._configVault;
      module.exports._parseVault = DotenvModule._parseVault;
      module.exports.config = DotenvModule.config;
      module.exports.decrypt = DotenvModule.decrypt;
      module.exports.parse = DotenvModule.parse;
      module.exports.populate = DotenvModule.populate;
      module.exports = DotenvModule;
    }
  });

  // src/index.ts
  var import_generator_helper = __toESM(require_dist2());

  // src/generate.ts
  var path = __toESM(__require("node:path"));
  var child_process = __toESM(__require("node:child_process"));
  var import_node_fs = __toESM(__require("node:fs"));
  var import_node_os = __toESM(__require("node:os"));
  var dotenv = __toESM(require_main());
  dotenv.config();
  function getDataModelFieldWithoutParsing(parsed) {
    const startOfField = parsed.indexOf('"datamodel"');
    const openingBracket = parsed.indexOf("{", startOfField);
    let numberOfOpeningBrackets = 0;
    let closingBracket = openingBracket;
    while (closingBracket < parsed.length) {
      const char = parsed[closingBracket++];
      if (char === "{") {
        numberOfOpeningBrackets++;
      } else if (char === "}") {
        numberOfOpeningBrackets--;
        if (numberOfOpeningBrackets === 0) {
          break;
        }
      }
    }
    return parsed.slice(openingBracket, closingBracket);
  }
  async function parseDatamodel(engine, model, tmpDir) {
    const tmpSchema = path.resolve(path.join(tmpDir, "schema.prisma"));
    import_node_fs.default.writeFileSync(tmpSchema, model);
    const parsed = await new Promise((resolve2, reject) => {
      const process2 = child_process.exec(
        `"${engine}" --datamodel-path="${tmpSchema}" cli dmmf`
      );
      let output = "";
      process2.stderr?.on("data", (l) => {
        if (l.includes("error:")) {
          reject(l.slice(l.indexOf("error:"), l.indexOf("\\n")));
        }
      });
      process2.stdout?.on("data", (d) => {
        output += d;
      });
      process2.on("exit", () => {
        resolve2(output);
      });
    });
    return getDataModelFieldWithoutParsing(parsed);
  }
  function renderDml(dml, options) {
    const {
      tableOnly = false,
      ignoreEnums = false,
      includeRelationFromFields = false,
      disableEmoji = false
    } = options ?? {};
    const diagram = "erDiagram";
    const modellikes = dml.models.concat(dml.types);
    const enums = tableOnly || ignoreEnums ? "" : dml.enums.map(
      (model) => `
        ${model.dbName || model.name} {
            ${model.values.map(
        (value) => `${value.name || value.dbName} ${value.dbName || value.name}`
      ).join("\n")}
        }
    `
    ).join("\n\n");
    const pkSigil = disableEmoji ? '"PK"' : '"\u{1F5DD}\uFE0F"';
    const nullableSigil = disableEmoji ? '"nullable"' : '"\u2753"';
    const classes = modellikes.map(
      (model) => `  "${model.dbName || model.name}" {
${tableOnly ? "" : model.fields.filter(isFieldShownInSchema(model, includeRelationFromFields)).map((field) => {
        return `    ${field.type.trimStart()} ${field.name.replace(
          /^_/,
          "z_"
        )} ${field.isId || model.primaryKey?.fields?.includes(field.name) ? pkSigil : ""}${field.isRequired ? "" : nullableSigil}`;
      }).join("\n")}
    }
  `
    ).join("\n\n");
    let relationships = "";
    for (const model of modellikes) {
      for (const field of model.fields) {
        const isEnum = field.kind === "enum";
        if (isEnum && (tableOnly || ignoreEnums)) {
          continue;
        }
        const relationshipName = `${isEnum ? "enum:" : ""}${field.name}`;
        const thisSide = `"${model.dbName || model.name}"`;
        const otherSide = `"${modellikes.find((ml) => ml.name === field.type)?.dbName || field.type}"`;
        if (field.relationFromFields && field.relationFromFields.length > 0 || isEnum) {
          let thisSideMultiplicity = "||";
          if (field.isList) {
            thisSideMultiplicity = "}o";
          } else if (!field.isRequired) {
            thisSideMultiplicity = "|o";
          }
          const otherModel = modellikes.find(
            (model2) => model2.name === otherSide
          );
          const otherField = otherModel?.fields.find(
            ({ relationName }) => relationName === field.relationName
          );
          const otherSideMultiplicity = thisSideMultiplicity;
          if (otherField?.isList) {
            thisSideMultiplicity = "o{";
          } else if (!otherField?.isRequired) {
            thisSideMultiplicity = "o|";
          }
          relationships += `    ${thisSide} ${thisSideMultiplicity}--${otherSideMultiplicity} ${otherModel?.dbName || otherSide} : "${relationshipName}"
`;
        } else if (modellikes.find(
          (m) => m.name === field.type || m.dbName === field.type
        ) && field.relationFromFields?.length === 0) {
          relationships += `    ${thisSide} o{--}o ${otherSide} : "${field.name}"
`;
        } else if (field.kind === "object") {
          const otherSideCompositeType = dml.types.find(
            (model2) => model2.name.replace(/^_/, "z_").replace(/\s/g, "")
            // remove spaces === otherSide
          );
          console.log(otherSide, otherSideCompositeType);
          if (otherSideCompositeType) {
            let thisSideMultiplicity = "||";
            if (field.isList) {
              thisSideMultiplicity = "}o";
            } else if (!field.isRequired) {
              thisSideMultiplicity = "|o";
            }
            const otherField = otherSideCompositeType?.fields.find(
              ({ relationName }) => relationName === field.relationName
            );
            const otherSideMultiplicity = thisSideMultiplicity;
            if (otherField?.isList) {
              thisSideMultiplicity = "o{";
            } else if (!otherField?.isRequired) {
              thisSideMultiplicity = "o|";
            }
            relationships += `    ${thisSide} ${thisSideMultiplicity}--${otherSideMultiplicity} ${otherSideCompositeType.dbName || otherSide} : "${relationshipName}"
`;
          }
        }
      }
    }
    return `${diagram}
${enums}
${classes}
${relationships}`;
  }
  var isFieldShownInSchema = (model, includeRelationFromFields) => (field) => {
    if (includeRelationFromFields) {
      return field.kind !== "object";
    }
    return field.kind !== "object" && !model.fields.find(
      ({ relationFromFields }) => relationFromFields?.includes(field.name)
    );
  };
  var mapPrismaToDb = (dmlModels, dataModel) => {
    const splitDataModel = dataModel?.split("\n").filter((line) => line.includes("@map") || line.includes("model ")).map((line) => line.trim());
    return dmlModels.map((model) => {
      return {
        ...model,
        fields: model.fields.map((field) => {
          let filterStatus = "None";
          const lineInDataModel = splitDataModel.filter((line) => {
            if (filterStatus === "Match" && line.includes("model ")) {
              filterStatus = "End";
            }
            if (filterStatus === "None" && line.includes(`model ${model.name} `)) {
              filterStatus = "Match";
            }
            return filterStatus === "Match";
          }).find(
            (line) => line.includes(`${field.name} `) && line.includes("@map")
          );
          if (lineInDataModel) {
            const regex = new RegExp(/@map\(\"(.*?)\"\)/, "g");
            const match = regex.exec(lineInDataModel);
            if (match?.[1]) {
              const name = match[1].replace(/^_/, "z_").replace(/\s/g, "");
              field.name = name;
            }
          }
          return field;
        })
      };
    });
  };
  var generate_default = async (options) => {
    try {
      const output = options.generator.output?.value || "./prisma/ERD.svg";
      const config2 = options.generator.config;
      const theme = config2.theme ?? "forest";
      let mermaidCliNodePath = path.resolve(
        path.join(config2.mmdcPath || "node_modules/.bin", "mmdc")
      );
      const tableOnly = config2.tableOnly === "true";
      const disableEmoji = config2.disableEmoji === "true";
      const ignoreEnums = config2.ignoreEnums === "true";
      const includeRelationFromFields = config2.includeRelationFromFields === "true";
      const disabled2 = process.env.DISABLE_ERD === "true" || config2.disabled === "true";
      const debug = config2.erdDebug === "true" || Boolean(process.env.ERD_DEBUG);
      if (debug) {
        console.log("debug mode enabled");
        console.log("config", config2);
      }
      if (disabled2) {
        return console.log("ERD generator is disabled");
      }
      const queryEngines = Object.values(options.binaryPaths?.queryEngine || {});
      if (!queryEngines[0])
        throw new Error("no query engine found");
      const queryEngine = queryEngines[0];
      const tmpDir = import_node_fs.default.mkdtempSync(`${import_node_os.default.tmpdir() + path.sep}prisma-erd-`);
      const datamodelString = await parseDatamodel(
        queryEngine,
        options.datamodel,
        tmpDir
      );
      if (!datamodelString) {
        throw new Error("could not parse datamodel");
      }
      if (debug && datamodelString) {
        import_node_fs.default.mkdirSync(path.resolve("prisma/debug"), { recursive: true });
        const dataModelFile = path.resolve("prisma/debug/1-datamodel.json");
        import_node_fs.default.writeFileSync(dataModelFile, datamodelString);
        console.log(`data model written to ${dataModelFile}`);
      }
      const dml = JSON.parse(datamodelString);
      dml.models = mapPrismaToDb(dml.models, options.datamodel);
      if (!dml.types) {
        dml.types = [];
      }
      if (debug && dml.models) {
        const mapAppliedFile = path.resolve(
          "prisma/debug/2-datamodel-map-applied.json"
        );
        import_node_fs.default.writeFileSync(mapAppliedFile, JSON.stringify(dml, null, 2));
        console.log(`applied @map to fields written to ${mapAppliedFile}`);
      }
      const mermaid = renderDml(dml, {
        tableOnly,
        ignoreEnums,
        includeRelationFromFields,
        disableEmoji
      });
      if (debug && mermaid) {
        const mermaidFile = path.resolve("prisma/debug/3-mermaid.mmd");
        import_node_fs.default.writeFileSync(mermaidFile, mermaid);
        console.log(`mermaid written to ${mermaidFile}`);
      }
      if (!mermaid)
        throw new Error("failed to construct mermaid instance from dml");
      if (output.endsWith(".md"))
        return import_node_fs.default.writeFileSync(output, `\`\`\`mermaid
${mermaid}\`\`\`
`);
      const tempMermaidFile = path.resolve(path.join(tmpDir, "prisma.mmd"));
      import_node_fs.default.writeFileSync(tempMermaidFile, mermaid);
      const defaultMermaidConfig = {
        deterministicIds: true,
        maxTextSize: 9e4,
        er: {
          useMaxWidth: true
        },
        theme
      };
      let mermaidConfig = defaultMermaidConfig;
      if (config2?.mermaidConfig) {
        const importedMermaidConfig = await import(path.resolve(config2.mermaidConfig));
        if (debug) {
          console.log("imported mermaid config: ", importedMermaidConfig);
        }
        mermaidConfig = {
          ...defaultMermaidConfig,
          ...importedMermaidConfig
        };
      }
      const tempConfigFile = path.resolve(path.join(tmpDir, "config.json"));
      import_node_fs.default.writeFileSync(tempConfigFile, JSON.stringify(mermaidConfig));
      let puppeteerConfig = config2.puppeteerConfig;
      if (puppeteerConfig && !import_node_fs.default.existsSync(puppeteerConfig)) {
        throw new Error(
          `Puppeteer config file "${puppeteerConfig}" does not exist`
        );
      }
      if (!puppeteerConfig) {
        const tempPuppeteerConfigFile = path.resolve(
          path.join(tmpDir, "puppeteerConfig.json")
        );
        let executablePath;
        const puppeteerConfigJson = {
          logLevel: debug ? "warn" : "error",
          executablePath
        };
        if (import_node_os.default.platform() === "darwin" && import_node_os.default.arch() === "arm64") {
          try {
            const executablePath2 = child_process.execSync("which chromium").toString().replace("\n", "");
            if (!executablePath2) {
              throw new Error(
                "Could not find chromium executable. Refer to https://github.com/keonik/prisma-erd-generator#issues for next steps."
              );
            }
            puppeteerConfigJson.executablePath = executablePath2;
            puppeteerConfigJson.args = ["--no-sandbox"];
          } catch (error) {
            console.error(error);
            console.log(
              `
Prisma ERD Generator: Unable to find chromium path for you MacOS arm64 machine. Attempting to use the default at ${executablePath}. To learn more visit https://github.com/keonik/prisma-erd-generator#-arm64-users-
`
            );
            executablePath = "/usr/bin/chromium-browser";
          }
        }
        import_node_fs.default.writeFileSync(
          tempPuppeteerConfigFile,
          JSON.stringify(puppeteerConfigJson)
        );
        puppeteerConfig = tempPuppeteerConfigFile;
      }
      if (config2.mmdcPath) {
        if (!import_node_fs.default.existsSync(mermaidCliNodePath)) {
          throw new Error(
            `
Mermaid CLI provided path does not exist. 
${mermaidCliNodePath}`
          );
        }
      } else if (!import_node_fs.default.existsSync(mermaidCliNodePath)) {
        const findMermaidCli = child_process.execSync("find ../.. -name mmdc").toString().split("\n").filter((path2) => path2).pop();
        if (!findMermaidCli || !import_node_fs.default.existsSync(findMermaidCli)) {
          throw new Error(
            `Expected mermaid CLI at 
${mermaidCliNodePath}

or
${findMermaidCli}
 but this package was not found.`
          );
        }
        mermaidCliNodePath = path.resolve(findMermaidCli);
      }
      const mermaidCommand = `"${mermaidCliNodePath}" -i "${tempMermaidFile}" -o "${output}" -c "${tempConfigFile}" -p "${puppeteerConfig}"`;
      if (debug && mermaidCommand)
        console.log("mermaid command: ", mermaidCommand);
      child_process.execSync(mermaidCommand);
      if (!import_node_fs.default.existsSync(output)) {
        throw new Error(
          `Issue generating ER Diagram. Expected ${output} to be created`
        );
      }
    } catch (error) {
      console.error(error);
      throw error;
    }
  };

  // src/index.ts
  var import_fs = __require("fs");
  var disabled = process.env.DISABLE_ERD === "true";
  var packageJsonPath = "package.json";
  var packageJsonData = JSON.parse((0, import_fs.readFileSync)(packageJsonPath, "utf-8"));
  (0, import_generator_helper.generatorHandler)({
    onManifest: () => ({
      defaultOutput: disabled ? "N/A" : "ERD.svg",
      prettyName: disabled ? "No ERD" : "Entity-relationship-diagram",
      requiresEngines: ["queryEngine"],
      version: packageJsonData?.version
    }),
    onGenerate: generate_default
  });
})();
